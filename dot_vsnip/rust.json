{
  "_HLDecomposition": {
    "prefix": "_hlDecomposition",
    "body": [
      "pub struct HLDecomposition {",
      "    n: usize,",
      "    root: usize,",
      "    g: Vec<Vec<usize>>,",
      "    parent: Vec<usize>,",
      "    depth: Vec<usize>,",
      "    heavy: Vec<usize>,",
      "    // 頂点番号の再割り当ての際に使う変数",
      "    t: usize,",
      "    // 頂点番号を再割り当てした際のindex",
      "    vid: Vec<usize>,",
      "    // vidの逆",
      "    inv: Vec<usize>,",
      "    // dfsに入って来たときのtの値",
      "    t_in: Vec<usize>,",
      "    // dfs戻るときのtの値",
      "    t_out: Vec<usize>,",
      "    // heavy edgeの親",
      "    head: Vec<usize>,",
      "    is_built: bool,",
      "}",
      "",
      "impl HLDecomposition {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            n,",
      "            root: usize::MAX,",
      "            g: vec![vec![]; n],",
      "            parent: vec![usize::MAX; n],",
      "            depth: vec![usize::MAX; n],",
      "            heavy: vec![usize::MAX; n],",
      "            t: 0,",
      "            vid: vec![usize::MAX; n],",
      "            inv: vec![usize::MAX; n],",
      "            t_in: vec![usize::MAX; n],",
      "            t_out: vec![usize::MAX; n],",
      "            head: (0..n).collect::<Vec<usize>>(),",
      "            is_built: false,",
      "        }",
      "    }",
      "    pub fn add(&mut self, u: usize, v: usize) {",
      "        self.g[u].push(v);",
      "        self.g[v].push(u);",
      "    }",
      "",
      "    pub fn build(&mut self, root: usize) {",
      "        assert!(self.n > 0);",
      "        self.root = root;",
      "        self.depth[root] = 0;",
      "        self.dfs(root, usize::MAX);",
      "        self.t = 0;",
      "        self.head[root] = root;",
      "        self.dfs_hld(root);",
      "        self.is_built = true;",
      "    }",
      "",
      "    pub fn lca(&self, mut u: usize, mut v: usize) -> usize {",
      "        debug_assert!(self.is_built);",
      "        while self.head[u] != self.head[v] {",
      "            if self.depth[self.head[u]] > self.depth[self.head[v]] {",
      "                u = self.parent[self.head[u]];",
      "            } else {",
      "                v = self.parent[self.head[v]];",
      "            }",
      "        }",
      "        if self.depth[u] < self.depth[v] {",
      "            u",
      "        } else {",
      "            v",
      "        }",
      "    }",
      "",
      "    pub fn distance(&self, u: usize, v: usize) -> usize {",
      "        debug_assert!(self.is_built);",
      "        let l = self.lca(u, v);",
      "        self.depth[u] + self.depth[v] - 2 * self.depth[l]",
      "    }",
      "",
      "    /// from → to のパス上で from から times 個進んだ頂点",
      "    pub fn go(&self, from: usize, to: usize, times: usize) -> Option<usize> {",
      "        debug_assert!(self.is_built);",
      "        let d = self.distance(from, to);",
      "        if times > d {",
      "            return None;",
      "        }",
      "        let lc = self.lca(from, to);",
      "        if lc == to {",
      "            return self.ancestor(from, times);",
      "        }",
      "        if lc == from {",
      "            return self.child(from, to, times);",
      "        }",
      "        let d_to_lca = self.distance(from, lc);",
      "        if times < d_to_lca {",
      "            self.ancestor(from, times)",
      "        } else if times == d_to_lca {",
      "            Some(lc)",
      "        } else {",
      "            let rest = times - d_to_lca;",
      "            self.child(lc, to, rest)",
      "        }",
      "    }",
      "",
      "    /// u-v パスを (vid 上の) 区間 [l, r] に分解して f(l, r) を呼ぶ",
      "    pub fn foreach<F>(&self, mut u: usize, mut v: usize, mut f: F)",
      "    where",
      "        F: FnMut(usize, usize),",
      "    {",
      "        debug_assert!(self.is_built);",
      "        while self.head[u] != self.head[v] {",
      "            if self.depth[self.head[u]] > self.depth[self.head[v]] {",
      "                std::mem::swap(&mut u, &mut v);",
      "            }",
      "            let hv = self.head[v];",
      "            let l = self.vid[hv];",
      "            let r = self.vid[v];",
      "            f(l, r);",
      "            v = self.parent[hv];",
      "        }",
      "",
      "        if self.vid[u] > self.vid[v] {",
      "            std::mem::swap(&mut u, &mut v);",
      "        }",
      "        f(self.vid[u], self.vid[v]);",
      "    }",
      "",
      "    // ── getter ──────────────────────────────────────────────────────────",
      "    pub fn g(&self) -> &Vec<Vec<usize>> {",
      "        &self.g",
      "    }",
      "    pub fn parent(&self) -> &Vec<usize> {",
      "        &self.parent",
      "    }",
      "    pub fn depth(&self) -> &Vec<usize> {",
      "        &self.depth",
      "    }",
      "    pub fn heavy(&self) -> &Vec<usize> {",
      "        &self.heavy",
      "    }",
      "    pub fn vid(&self) -> &Vec<usize> {",
      "        &self.vid",
      "    }",
      "    pub fn inv(&self) -> &Vec<usize> {",
      "        &self.inv",
      "    }",
      "    pub fn t_in(&self) -> &Vec<usize> {",
      "        &self.t_in",
      "    }",
      "    pub fn t_out(&self) -> &Vec<usize> {",
      "        &self.t_out",
      "    }",
      "    pub fn head(&self) -> &Vec<usize> {",
      "        &self.head",
      "    }",
      "",
      "    // ── internal ────────────────────────────────────────────────────────",
      "    // rootから見た部分木のコスト・深さ最大値・heavy edgeの計算",
      "    fn dfs(&mut self, v: usize, p: usize) -> usize {",
      "        self.parent[v] = p;",
      "        let mut acc = 1;",
      "        let mut m = 0;",
      "        for &v2 in self.g[v].to_owned().iter() {",
      "            if v2 == p {",
      "                continue;",
      "            }",
      "            self.depth[v2] = self.depth[v] + 1;",
      "            let next = self.dfs(v2, v);",
      "            acc += next;",
      "            if next > m {",
      "                m = next;",
      "                self.heavy[v] = v2;",
      "            }",
      "        }",
      "        acc",
      "    }",
      "",
      "    fn dfs_hld(&mut self, v: usize) {",
      "        self.vid[v] = self.t;",
      "        self.inv[self.t] = v;",
      "        self.t_in[v] = self.t;",
      "        self.t += 1usize;",
      "",
      "        if self.heavy[v] != usize::MAX {",
      "            let next = self.heavy[v];",
      "            self.head[next] = self.head[v];",
      "            self.dfs_hld(next);",
      "        }",
      "",
      "        for &v2 in self.g[v].to_owned().iter() {",
      "            if v2 == self.parent[v] || v2 == self.heavy[v] {",
      "                continue;",
      "            }",
      "            self.head[v2] = v2;",
      "            self.dfs_hld(v2);",
      "        }",
      "        self.t_out[v] = self.t;",
      "    }",
      "",
      "    // vのk個上の親頂点を返す",
      "    fn ancestor(&self, mut v: usize, mut k: usize) -> Option<usize> {",
      "        while k > 0 {",
      "            let h = self.head[v];",
      "            let d_on_chain = self.depth[v] - self.depth[h];",
      "",
      "            if k <= d_on_chain {",
      "                return Some(self.inv[self.vid[v] - k]);",
      "            }",
      "",
      "            k -= d_on_chain + 1;",
      "            if self.parent[h] == usize::MAX {",
      "                return None;",
      "            }",
      "            v = self.parent[h];",
      "        }",
      "        Some(v)",
      "    }",
      "",
      "    // parent -> childのパスでparentからtimes個だけ進んだ頂点",
      "    fn child(&self, parent: usize, child: usize, times: usize) -> Option<usize> {",
      "        assert!(self.depth[parent] < self.depth[child]);",
      "        let d = self.distance(parent, child);",
      "        if times > d {",
      "            return None;",
      "        }",
      "        let up = d - times;",
      "        self.ancestor(child, up)",
      "    }",
      "}"
    ]
  },
  "_HLDecomposition_with_test": {
    "prefix": "_hlDecomposition_with_test",
    "body": [
      "pub struct HLDecomposition {",
      "    n: usize,",
      "    root: usize,",
      "    g: Vec<Vec<usize>>,",
      "    parent: Vec<usize>,",
      "    depth: Vec<usize>,",
      "    heavy: Vec<usize>,",
      "    // 頂点番号の再割り当ての際に使う変数",
      "    t: usize,",
      "    // 頂点番号を再割り当てした際のindex",
      "    vid: Vec<usize>,",
      "    // vidの逆",
      "    inv: Vec<usize>,",
      "    // dfsに入って来たときのtの値",
      "    t_in: Vec<usize>,",
      "    // dfs戻るときのtの値",
      "    t_out: Vec<usize>,",
      "    // heavy edgeの親",
      "    head: Vec<usize>,",
      "    is_built: bool,",
      "}",
      "",
      "impl HLDecomposition {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            n,",
      "            root: usize::MAX,",
      "            g: vec![vec![]; n],",
      "            parent: vec![usize::MAX; n],",
      "            depth: vec![usize::MAX; n],",
      "            heavy: vec![usize::MAX; n],",
      "            t: 0,",
      "            vid: vec![usize::MAX; n],",
      "            inv: vec![usize::MAX; n],",
      "            t_in: vec![usize::MAX; n],",
      "            t_out: vec![usize::MAX; n],",
      "            head: (0..n).collect::<Vec<usize>>(),",
      "            is_built: false,",
      "        }",
      "    }",
      "    pub fn add(&mut self, u: usize, v: usize) {",
      "        self.g[u].push(v);",
      "        self.g[v].push(u);",
      "    }",
      "",
      "    pub fn build(&mut self, root: usize) {",
      "        assert!(self.n > 0);",
      "        self.root = root;",
      "        self.depth[root] = 0;",
      "        self.dfs(root, usize::MAX);",
      "        self.t = 0;",
      "        self.head[root] = root;",
      "        self.dfs_hld(root);",
      "        self.is_built = true;",
      "    }",
      "",
      "    pub fn lca(&self, mut u: usize, mut v: usize) -> usize {",
      "        debug_assert!(self.is_built);",
      "        while self.head[u] != self.head[v] {",
      "            if self.depth[self.head[u]] > self.depth[self.head[v]] {",
      "                u = self.parent[self.head[u]];",
      "            } else {",
      "                v = self.parent[self.head[v]];",
      "            }",
      "        }",
      "        if self.depth[u] < self.depth[v] {",
      "            u",
      "        } else {",
      "            v",
      "        }",
      "    }",
      "",
      "    pub fn distance(&self, u: usize, v: usize) -> usize {",
      "        debug_assert!(self.is_built);",
      "        let l = self.lca(u, v);",
      "        self.depth[u] + self.depth[v] - 2 * self.depth[l]",
      "    }",
      "",
      "    /// from → to のパス上で from から times 個進んだ頂点",
      "    pub fn go(&self, from: usize, to: usize, times: usize) -> Option<usize> {",
      "        debug_assert!(self.is_built);",
      "        let d = self.distance(from, to);",
      "        if times > d {",
      "            return None;",
      "        }",
      "        let lc = self.lca(from, to);",
      "        if lc == to {",
      "            return self.ancestor(from, times);",
      "        }",
      "        if lc == from {",
      "            return self.child(from, to, times);",
      "        }",
      "        let d_to_lca = self.distance(from, lc);",
      "        if times < d_to_lca {",
      "            self.ancestor(from, times)",
      "        } else if times == d_to_lca {",
      "            Some(lc)",
      "        } else {",
      "            let rest = times - d_to_lca;",
      "            self.child(lc, to, rest)",
      "        }",
      "    }",
      "",
      "    /// u-v パスを (vid 上の) 区間 [l, r] に分解して f(l, r) を呼ぶ",
      "    pub fn foreach<F>(&self, mut u: usize, mut v: usize, mut f: F)",
      "    where",
      "        F: FnMut(usize, usize),",
      "    {",
      "        debug_assert!(self.is_built);",
      "        while self.head[u] != self.head[v] {",
      "            if self.depth[self.head[u]] > self.depth[self.head[v]] {",
      "                std::mem::swap(&mut u, &mut v);",
      "            }",
      "            let hv = self.head[v];",
      "            let l = self.vid[hv];",
      "            let r = self.vid[v];",
      "            f(l, r);",
      "            v = self.parent[hv];",
      "        }",
      "",
      "        if self.vid[u] > self.vid[v] {",
      "            std::mem::swap(&mut u, &mut v);",
      "        }",
      "        f(self.vid[u], self.vid[v]);",
      "    }",
      "",
      "    // ── getter ──────────────────────────────────────────────────────────",
      "    pub fn g(&self) -> &Vec<Vec<usize>> {",
      "        &self.g",
      "    }",
      "    pub fn parent(&self) -> &Vec<usize> {",
      "        &self.parent",
      "    }",
      "    pub fn depth(&self) -> &Vec<usize> {",
      "        &self.depth",
      "    }",
      "    pub fn heavy(&self) -> &Vec<usize> {",
      "        &self.heavy",
      "    }",
      "    pub fn vid(&self) -> &Vec<usize> {",
      "        &self.vid",
      "    }",
      "    pub fn inv(&self) -> &Vec<usize> {",
      "        &self.inv",
      "    }",
      "    pub fn t_in(&self) -> &Vec<usize> {",
      "        &self.t_in",
      "    }",
      "    pub fn t_out(&self) -> &Vec<usize> {",
      "        &self.t_out",
      "    }",
      "    pub fn head(&self) -> &Vec<usize> {",
      "        &self.head",
      "    }",
      "",
      "    // ── internal ────────────────────────────────────────────────────────",
      "    // rootから見た部分木のコスト・深さ最大値・heavy edgeの計算",
      "    fn dfs(&mut self, v: usize, p: usize) -> usize {",
      "        self.parent[v] = p;",
      "        let mut acc = 1;",
      "        let mut m = 0;",
      "        for &v2 in self.g[v].to_owned().iter() {",
      "            if v2 == p {",
      "                continue;",
      "            }",
      "            self.depth[v2] = self.depth[v] + 1;",
      "            let next = self.dfs(v2, v);",
      "            acc += next;",
      "            if next > m {",
      "                m = next;",
      "                self.heavy[v] = v2;",
      "            }",
      "        }",
      "        acc",
      "    }",
      "",
      "    fn dfs_hld(&mut self, v: usize) {",
      "        self.vid[v] = self.t;",
      "        self.inv[self.t] = v;",
      "        self.t_in[v] = self.t;",
      "        self.t += 1usize;",
      "",
      "        if self.heavy[v] != usize::MAX {",
      "            let next = self.heavy[v];",
      "            self.head[next] = self.head[v];",
      "            self.dfs_hld(next);",
      "        }",
      "",
      "        for &v2 in self.g[v].to_owned().iter() {",
      "            if v2 == self.parent[v] || v2 == self.heavy[v] {",
      "                continue;",
      "            }",
      "            self.head[v2] = v2;",
      "            self.dfs_hld(v2);",
      "        }",
      "        self.t_out[v] = self.t;",
      "    }",
      "",
      "    // vのk個上の親頂点を返す",
      "    fn ancestor(&self, mut v: usize, mut k: usize) -> Option<usize> {",
      "        while k > 0 {",
      "            let h = self.head[v];",
      "            let d_on_chain = self.depth[v] - self.depth[h];",
      "",
      "            if k <= d_on_chain {",
      "                return Some(self.inv[self.vid[v] - k]);",
      "            }",
      "",
      "            k -= d_on_chain + 1;",
      "            if self.parent[h] == usize::MAX {",
      "                return None;",
      "            }",
      "            v = self.parent[h];",
      "        }",
      "        Some(v)",
      "    }",
      "",
      "    // parent -> childのパスでparentからtimes個だけ進んだ頂点",
      "    fn child(&self, parent: usize, child: usize, times: usize) -> Option<usize> {",
      "        assert!(self.depth[parent] < self.depth[child]);",
      "        let d = self.distance(parent, child);",
      "        if times > d {",
      "            return None;",
      "        }",
      "        let up = d - times;",
      "        self.ancestor(child, up)",
      "    }",
      "}",
      "",
      "#[cfg(test)]",
      "mod tests {",
      "    use super::*;",
      "",
      "    /// 0-1-2-...-(n-1) という一直線の木を作る",
      "    fn build_chain(n: usize) -> HLDecomposition {",
      "        let mut hld = HLDecomposition::new(n);",
      "        for i in 0..(n - 1) {",
      "            hld.add(i, i + 1);",
      "        }",
      "        hld.build(0);",
      "        hld",
      "    }",
      "",
      "    // 例示用の木:",
      "    //        0",
      "    //      / | \\",
      "    //     1  2  3",
      "    //    / \\ / \\",
      "    //   4  5 6  7",
      "    fn build_example_tree() -> HLDecomposition {",
      "        let mut hld = HLDecomposition::new(8);",
      "        hld.add(0, 1);",
      "        hld.add(0, 2);",
      "        hld.add(0, 3);",
      "        hld.add(1, 4);",
      "        hld.add(1, 5);",
      "        hld.add(2, 6);",
      "        hld.add(2, 7);",
      "        hld.build(0);",
      "        hld",
      "    }",
      "",
      "    #[test]",
      "    fn test_lca_chain() {",
      "        let hld = build_chain(5);",
      "",
      "        assert_eq!(hld.lca(0, 0), 0);",
      "        assert_eq!(hld.lca(3, 3), 3);",
      "",
      "        assert_eq!(hld.lca(0, 4), 0);",
      "        assert_eq!(hld.lca(1, 4), 1);",
      "        assert_eq!(hld.lca(2, 4), 2);",
      "",
      "        assert_eq!(hld.lca(4, 1), 1);",
      "    }",
      "",
      "    #[test]",
      "    fn test_lca_tree() {",
      "        let hld = build_example_tree();",
      "",
      "        assert_eq!(hld.lca(4, 5), 1);",
      "        assert_eq!(hld.lca(6, 7), 2);",
      "",
      "        assert_eq!(hld.lca(1, 4), 1);",
      "        assert_eq!(hld.lca(2, 6), 2);",
      "",
      "        assert_eq!(hld.lca(4, 6), 0);",
      "        assert_eq!(hld.lca(5, 3), 0);",
      "    }",
      "",
      "    #[test]",
      "    fn test_distance_chain() {",
      "        let hld = build_chain(5);",
      "",
      "        assert_eq!(hld.distance(0, 0), 0);",
      "        assert_eq!(hld.distance(0, 1), 1);",
      "        assert_eq!(hld.distance(0, 4), 4);",
      "        assert_eq!(hld.distance(1, 4), 3);",
      "        assert_eq!(hld.distance(2, 4), 2);",
      "",
      "        assert_eq!(hld.distance(4, 0), 4);",
      "        assert_eq!(hld.distance(4, 1), 3);",
      "    }",
      "",
      "    #[test]",
      "    fn test_distance_tree() {",
      "        let hld = build_example_tree();",
      "",
      "        assert_eq!(hld.distance(4, 5), 2);",
      "        assert_eq!(hld.distance(6, 7), 2);",
      "",
      "        assert_eq!(hld.distance(4, 6), 4);",
      "        assert_eq!(hld.distance(5, 3), 3);",
      "",
      "        assert_eq!(hld.distance(0, 0), 0);",
      "    }",
      "",
      "    #[test]",
      "    fn test_go_chain_forward_and_backward() {",
      "        let hld = build_chain(5);",
      "",
      "        // 0 - 1 - 2 - 3 - 4 - 5",
      "        assert_eq!(hld.go(0, 4, 0), Some(0));",
      "        assert_eq!(hld.go(0, 4, 1), Some(1));",
      "        assert_eq!(hld.go(0, 4, 2), Some(2));",
      "        assert_eq!(hld.go(0, 4, 3), Some(3));",
      "        assert_eq!(hld.go(0, 4, 4), Some(4));",
      "        assert_eq!(hld.go(0, 4, 5), None);",
      "",
      "        assert_eq!(hld.go(4, 0, 0), Some(4));",
      "        assert_eq!(hld.go(4, 0, 1), Some(3));",
      "        assert_eq!(hld.go(4, 0, 2), Some(2));",
      "        assert_eq!(hld.go(4, 0, 3), Some(1));",
      "        assert_eq!(hld.go(4, 0, 4), Some(0));",
      "        assert_eq!(hld.go(4, 0, 5), None);",
      "    }",
      "",
      "    #[test]",
      "    fn test_go_same_vertex() {",
      "        let hld = build_example_tree();",
      "",
      "        assert_eq!(hld.go(4, 4, 0), Some(4));",
      "        assert_eq!(hld.go(4, 4, 1), None);",
      "    }",
      "",
      "    #[test]",
      "    fn test_go_through_lca() {",
      "        let hld = build_example_tree();",
      "        //        0",
      "        //      / | \\",
      "        //     1  2  3",
      "        //    / \\ / \\",
      "        //   4  5 6  7",
      "        assert_eq!(hld.distance(4, 7), 4);",
      "",
      "        assert_eq!(hld.go(4, 7, 0), Some(4));",
      "        assert_eq!(hld.go(4, 7, 1), Some(1));",
      "        assert_eq!(hld.go(4, 7, 2), Some(0));",
      "        assert_eq!(hld.go(4, 7, 3), Some(2));",
      "        assert_eq!(hld.go(4, 7, 4), Some(7));",
      "        assert_eq!(hld.go(4, 7, 5), None);",
      "    }",
      "    // 0",
      "    // └1",
      "    //   ├2",
      "    //   └3",
      "    //     └4",
      "    //       ├5",
      "    //       └6",
      "    //",
      "    fn build_sample_tree() -> HLDecomposition {",
      "        let n = 7;",
      "        let mut hld = HLDecomposition::new(n);",
      "        hld.add(0, 1);",
      "        hld.add(1, 2);",
      "        hld.add(1, 3);",
      "        hld.add(3, 4);",
      "        hld.add(4, 5);",
      "        hld.add(4, 6);",
      "        hld.build(0);",
      "        hld",
      "    }",
      "",
      "    fn collect_segments(hld: &HLDecomposition, u: usize, v: usize) -> Vec<(usize, usize)> {",
      "        let mut segs = Vec::new();",
      "        hld.foreach(u, v, |l, r| {",
      "            segs.push((l, r));",
      "        });",
      "        segs",
      "    }",
      "",
      "    fn collect_nodes_from_foreach(hld: &HLDecomposition, u: usize, v: usize) -> Vec<usize> {",
      "        let mut nodes = Vec::new();",
      "        hld.foreach(u, v, |l, r| {",
      "            for i in l..=r {",
      "                nodes.push(hld.inv[i]);",
      "            }",
      "        });",
      "        nodes",
      "    }",
      "",
      "    #[test]",
      "    fn foreach_segments_2_to_5() {",
      "        let hld = build_sample_tree();",
      "        let segs = collect_segments(&hld, 2, 5);",
      "",
      "        assert_eq!(segs, vec![(6, 6), (1, 4)]);",
      "",
      "        let mut nodes = collect_nodes_from_foreach(&hld, 2, 5);",
      "        nodes.sort_unstable();",
      "        assert_eq!(nodes, vec![1, 2, 3, 4, 5]);",
      "    }",
      "",
      "    #[test]",
      "    fn foreach_segments_2_to_6() {",
      "        let hld = build_sample_tree();",
      "        let segs = collect_segments(&hld, 2, 6);",
      "",
      "        assert_eq!(segs, vec![(5, 5), (6, 6), (1, 3)]);",
      "",
      "        let mut nodes = collect_nodes_from_foreach(&hld, 2, 6);",
      "        nodes.sort_unstable();",
      "        assert_eq!(nodes, vec![1, 2, 3, 4, 6]);",
      "    }",
      "}"
    ]
  },
  "_alpha": {
    "prefix": "_alpha",
    "body": [
      "let alpha = ('a'..='z').collect_vec();"
    ]
  },
  "_angle_sort": {
    "prefix": "_angle_sort_henkaku",
    "body": [
      "pub mod angle_sort {",
      "    use std::cmp::Ordering;",
      "",
      "    type P = (isize, isize);",
      "",
      "    pub(crate) fn angle_sort(pts: &mut [P], base: (isize, isize)) {",
      "        let (bx, by) = base;",
      "        let upper = |&(ax, ay): &P| {",
      "            let dy = ay - by;",
      "            let dx = ax - bx;",
      "            dy > 0 || (dy == 0 && dx >= 0)",
      "        };",
      "",
      "        pts.sort_by(|&a, &b| {",
      "            let ua = upper(&a);",
      "            let ub = upper(&b);",
      "            if ua != ub {",
      "                return if ua {",
      "                    Ordering::Less",
      "                } else {",
      "                    Ordering::Greater",
      "                };",
      "            }",
      "            let ax = a.0 - bx;",
      "            let ay = a.1 - by;",
      "            let bxv = b.0 - bx;",
      "            let byv = b.1 - by;",
      "            let cross = ax * byv - ay * bxv;",
      "            if cross != 0 {",
      "                return if cross > 0 {",
      "                    Ordering::Less",
      "                } else {",
      "                    Ordering::Greater",
      "                };",
      "            }",
      "            let da = ax * ax + ay * ay;",
      "            let db = bxv * bxv + byv * byv;",
      "            da.cmp(&db)",
      "        });",
      "    }",
      "",
      "    #[cfg(test)]",
      "    mod tests {",
      "        use super::*;",
      "",
      "        #[test]",
      "        fn test_angle_sort() {",
      "            let mut pts = vec![",
      "                (1, 0),   // 0°",
      "                (1, 1),   // 45°",
      "                (0, 1),   // 90°",
      "                (-1, 1),  // 135°",
      "                (-1, 0),  // 180°",
      "                (-1, -1), // -135° -> 225°",
      "                (0, -1),  // -90° -> 270°",
      "                (1, -1),  // -45° -> 315°",
      "            ];",
      "            angle_sort(&mut pts, (0, 0));",
      "            assert_eq!(",
      "                pts,",
      "                vec![",
      "                    (1, 0),",
      "                    (1, 1),",
      "                    (0, 1),",
      "                    (-1, 1),",
      "                    (-1, 0),",
      "                    (-1, -1),",
      "                    (0, -1),",
      "                    (1, -1),",
      "                ]",
      "            );",
      "        }",
      "        #[test]",
      "        fn test_base_offset_quadrants() {",
      "            let base = (10, 10);",
      "            let mut pts = vec![",
      "                (11, 10), //  0°",
      "                (10, 11), // 90°",
      "                (9, 10),  // 180°",
      "                (10, 9),  // 270°",
      "            ];",
      "            angle_sort(&mut pts, base);",
      "            assert_eq!(pts, vec![(11, 10), (10, 11), (9, 10), (10, 9),]);",
      "        }",
      "        #[test]",
      "        fn test_duplicates() {",
      "            let mut pts = vec![(1, 0), (0, 1), (1, 0), (0, 1)];",
      "            angle_sort(&mut pts, (0, 0));",
      "            assert_eq!(pts, vec![(1, 0), (1, 0), (0, 1), (0, 1)]);",
      "        }",
      "    }",
      "}",
      ""
    ]
  },
  "_ceil": {
    "prefix": "_ceil",
    "body": [
      "let ceil = |a: usize, b: usize| {",
      "    (a + b - 1) / b",
      "};"
    ],
    "description": "Ceil calculation"
  },
  "_ch": {
    "prefix": "_ch",
    "body": [
      "use easy_ext::ext;",
      "",
      "#[ext(Ch)]",
      "impl <T> T",
      "where",
      "    T: Copy + PartialOrd",
      "{",
      "    pub fn chmin(&mut self, rhs: T) -> bool {",
      "        if rhs < *self {",
      "            *self = rhs;",
      "            return true;",
      "        }",
      "        false",
      "    }",
      "    pub fn chmax(&mut self, rhs: T) -> bool {",
      "        if rhs > *self {",
      "            *self = rhs;",
      "            return true;",
      "        }",
      "        false",
      "    }",
      "}"
    ],
    "description": "Extension methods `chmin` and `chmax` for any `T: Copy + PartialOrd`"
  },
  "_chmax": {
    "prefix": "_chmax",
    "body": [
      "macro_rules! chmax {",
      "    (\\$val: expr, \\$new: expr) => {",
      "        if \\$val < \\$new {",
      "            \\$val = \\$new;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    };",
      "}"
    ],
    "description": "chmax"
  },
  "_chmin": {
    "prefix": "_chmin",
    "body": [
      "macro_rules! chmin {",
      "    (\\$val: expr, \\$new: expr) => {",
      "        if \\$val > \\$new {",
      "            \\$val = \\$new;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    };",
      "}"
    ],
    "description": "chmin"
  },
  "_coordinate_compression": {
    "prefix": "_coordinate_compression",
    "body": [
      "pub use coordinate_compression::*;",
      "pub mod coordinate_compression {",
      "    use std::{collections::HashMap, hash::Hash};",
      "",
      "    pub struct CoordinateComression<T: Ord + Copy + Hash + Eq> {",
      "        max_id: usize,",
      "        id_map: HashMap<T, usize>",
      "    }",
      "    impl<T: Ord + Copy + Hash + Eq> CoordinateComression<T> {",
      "        pub fn new(ary: &[T]) -> Self {",
      "            let mut id = 0;",
      "            let mut id_map = HashMap::new();",
      "            let mut ary = ary.to_owned();",
      "            ary.sort();",
      "            ary.dedup();",
      "            for &num in ary.iter() {",
      "                id_map.insert(num, id);",
      "                id += 1usize;",
      "            }",
      "            Self {",
      "                max_id: id,",
      "                id_map",
      "            }",
      "        }",
      "",
      "        pub fn get(&self, num: &T) -> usize {",
      "            self.id_map[num]",
      "        }",
      "",
      "        pub fn len(&self) -> usize {",
      "            self.max_id",
      "        }",
      "    }",
      "}",
      ""
    ]
  },
  "_cycle": {
    "prefix": "_cycle",
    "body": [
      "fn dfs(now: usize, pre: &mut Vec<Option<usize>>, g: &Vec<Vec<usize>>, ans: &mut Vec<usize>, p: usize) -> (usize, usize) {",
      "    for &v2 in g[now].iter() {",
      "        if v2 == p {",
      "            continue;",
      "        }",
      "        if !pre[v2].is_none() {",
      "            ans.push(now);",
      "            return (1, v2);",
      "        }",
      "        pre[v2] = Some(now);",
      "        let jud = dfs(v2, pre, g, ans, now);",
      "        if jud.0 == 1 {",
      "            ans.push(now);",
      "            if jud.1 == now {",
      "                return (0, usize::MAX);",
      "            } else {",
      "                return jud;",
      "            }",
      "        }",
      "    }",
      "    return (0, usize::MAX);",
      "}"
    ],
    "description": "DFS function for cycle detection in a graph"
  },
  "_degg": {
    "prefix": "_degg",
    "body": [
      "#[macro_export]",
      "macro_rules! degg {(\\$(\\$val:expr),+ \\$(,)?) => {println!(\"[{}:{}] {}\",file!(),line!(),{let mut parts = Vec::new();\\$(parts.push(format!(\"{} = {:?}\", stringify!(\\$val), &\\$val));)+parts.join(\", \")})}}"
    ]
  },
  "_didj": {
    "prefix": "_didj",
    "body": [
      "let didj = vec![(1, 0), (-1, 0), (0, 1), (0, -1)];"
    ],
    "description": "4 directions didj"
  },
  "_didj8": {
    "prefix": "_didj8",
    "body": [
      "let didj = vec![(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)];"
    ],
    "description": "8 directions didj"
  },
  "_double_ended_priority_queue": {
    "prefix": "_double_ended_priority_queue",
    "body": [
      "pub mod double_ended_priority_queue {",
      "    use std::collections::BTreeMap;",
      "    // trait教会を考えるのがだるすぎる",
      "    type T = isize;",
      "",
      "    pub struct DoubleEndedPriorityQueue {",
      "        map: BTreeMap<T, usize>,",
      "    }",
      "",
      "    impl DoubleEndedPriorityQueue {",
      "        /// mapの宣言。何もinsertしないよ",
      "        pub fn new() -> Self {",
      "            Self {",
      "                map: BTreeMap::new(),",
      "            }",
      "        }",
      "",
      "        pub fn insert(&mut self, x: T) {",
      "            self.map.entry(x).and_modify(|e| *e += 1).or_insert(1usize);",
      "        }",
      "        pub fn remove(&mut self, x: T) -> bool {",
      "            let &cc = self.map.get(&x).unwrap_or(&0);",
      "            if cc == 0 {",
      "                return false;",
      "            }",
      "            if cc == 1 {",
      "                self.map.remove(&x);",
      "                return true;",
      "            }",
      "            self.map.insert(x, cc - 1);",
      "            true",
      "        }",
      "",
      "        pub fn first(&self) -> Option<T> {",
      "            let (&f, _) = self.map.first_key_value()?;",
      "            Some(f)",
      "        }",
      "        pub fn last(&self) -> Option<T> {",
      "            let (&f, _) = self.map.last_key_value()?;",
      "            Some(f)",
      "        }",
      "        pub fn count(&self, x: T) -> usize {",
      "            let &c = self.map.get(&x).unwrap_or(&0);",
      "            c",
      "        }",
      "        pub fn pop_first(&mut self) -> Option<T> {",
      "            let num = self.first()?;",
      "            self.remove(num);",
      "            Some(num)",
      "        }",
      "        pub fn pop_last(&mut self) -> Option<T> {",
      "            let num = self.last()?;",
      "            self.remove(num);",
      "            Some(num)",
      "        }",
      "",
      "        /// immutableなgetter大好き！",
      "        pub fn map(&self) -> &BTreeMap<T, usize> {",
      "            &self.map",
      "        }",
      "    }",
      "}",
      ""
    ]
  },
  "_extgcd": {
    "prefix": "_extgcd",
    "body": [
      "fn extgcd(a: isize, b: isize, i: &mut isize, j: &mut isize) -> isize {",
      "    if b == 0 {",
      "        *i = 1;",
      "        *j = 0;",
      "        return a;",
      "    }",
      "    let p = a / b;",
      "    let g = extgcd(b, a - b * p, j, i);",
      "    *j -= p * *i;",
      "    g",
      "}"
    ],
    "description": "Extended Euclidean Algorithm to find GCD and coefficients"
  },
  "_fenwick_tree": {
    "prefix": "_fenwick_tree",
    "body": [
      "pub use fenwick_tree::*;",
      "mod fenwick_tree {",
      "    use std::ops::{Bound, RangeBounds};",
      "",
      "    #[derive(Clone)]",
      "    pub struct FenwickTree<T> {",
      "        n: usize,",
      "        ary: Vec<T>,",
      "        e: T,",
      "    }",
      "",
      "    impl<T: Clone + std::ops::AddAssign<T>> FenwickTree<T> {",
      "        pub fn new(n: usize, e: T) -> Self {",
      "            FenwickTree {",
      "                n,",
      "                ary: vec![e.clone(); n],",
      "                e,",
      "            }",
      "        }",
      "        pub fn accum(&self, mut idx: usize) -> T {",
      "            let mut sum = self.e.clone();",
      "            while idx > 0 {",
      "                sum += self.ary[idx - 1].clone();",
      "                idx &= idx - 1;",
      "            }",
      "            sum",
      "        }",
      "        /// performs data[idx] += val;",
      "        pub fn add<U: Clone>(&mut self, mut idx: usize, val: U)",
      "        where",
      "            T: std::ops::AddAssign<U>,",
      "        {",
      "            let n = self.n;",
      "            idx += 1;",
      "            while idx <= n {",
      "                self.ary[idx - 1] += val.clone();",
      "                idx += idx & idx.wrapping_neg();",
      "            }",
      "        }",
      "        /// Returns data[l] + ... + data[r - 1].",
      "        pub fn sum<R>(&self, range: R) -> T",
      "        where",
      "            T: std::ops::Sub<Output = T>,",
      "            R: RangeBounds<usize>,",
      "        {",
      "            let r = match range.end_bound() {",
      "                Bound::Included(r) => r + 1,",
      "                Bound::Excluded(r) => *r,",
      "                Bound::Unbounded => self.n,",
      "            };",
      "            let l = match range.start_bound() {",
      "                Bound::Included(l) => *l,",
      "                Bound::Excluded(l) => l + 1,",
      "                Bound::Unbounded => return self.accum(r),",
      "            };",
      "            self.accum(r) - self.accum(l)",
      "        }",
      "    }",
      "}"
    ]
  },
  "_frac": {
    "prefix": "_frac",
    "body": [
      "#[derive(Debug, Clone, Copy, Hash, Eq)]",
      "pub struct Frac(i128, i128);",
      "",
      "impl Frac {",
      "    pub fn new(a: i128, b: i128) -> Self {",
      "        Frac(a, b).normalize()",
      "    }",
      "",
      "    fn normalize(&mut self) -> Self {",
      "        let g = Self::gcd(self.0.abs(), self.1.abs());",
      "        self.0 /= g;",
      "        self.1 /= g;",
      "        if self.1 < 0 {",
      "            self.0 *= -1;",
      "            self.1 *= -1;",
      "        }",
      "        *self",
      "    }",
      "",
      "    pub fn from(x: i128) -> Self {",
      "        Frac(x, 1)",
      "    }",
      "",
      "    pub fn inv(&self) -> Self {",
      "        if self.0 > 0 {",
      "            Frac(self.1, self.0)",
      "        } else if self.0 < 0 {",
      "            Frac(-self.1, -self.0)",
      "        } else {",
      "            Frac(1, 0) //Infinity",
      "        }",
      "    }",
      "",
      "    fn gcd(a: i128, b: i128) -> i128 {",
      "        if b == 0 {",
      "            a",
      "        } else {",
      "            Self::gcd(b, a % b)",
      "        }",
      "    }",
      "",
      "    fn lcm(a: i128, b: i128) -> i128 {",
      "        a / Self::gcd(a, b) * b",
      "    }",
      "",
      "    pub fn is_inf(&self) -> bool {",
      "        *self == Self::new(1, 0) || *self == Self::new(-1, 0)",
      "    }",
      "",
      "    pub fn is_pinf(&self) -> bool {",
      "        *self == Self::new(1, 0)",
      "    }",
      "    pub fn is_minf(&self) -> bool {",
      "        *self == Self::new(-1, 0)",
      "    }",
      "}",
      "",
      "impl std::ops::Add<i128> for Frac {",
      "    type Output = Self;",
      "    fn add(self, z: i128) -> Self {",
      "        Self::new(self.0 + self.1 * z, self.1)",
      "    }",
      "}",
      "impl std::ops::Add for Frac {",
      "    type Output = Self;",
      "    fn add(self, other: Self) -> Self {",
      "        let num = Self::lcm(self.1, other.1);",
      "        let numerator = self.0 * num / self.1 + other.0 * num / other.1;",
      "        Self::new(numerator, num)",
      "    }",
      "}",
      "impl std::ops::AddAssign<i128> for Frac {",
      "    fn add_assign(&mut self, z: i128) {",
      "        self.0 += self.1 * z;",
      "        self.normalize();",
      "    }",
      "}",
      "impl std::ops::Sub<i128> for Frac {",
      "    type Output = Self;",
      "    fn sub(self, z: i128) -> Self {",
      "        self + (-z)",
      "    }",
      "}",
      "impl std::ops::Sub for Frac {",
      "    type Output = Self;",
      "    fn sub(self, other: Self) -> Self {",
      "        let num = Self::lcm(self.1, other.1);",
      "        let numerator = self.0 * num / self.1 - other.0 * num / other.1;",
      "        Self::new(numerator, num)",
      "    }",
      "}",
      "impl std::ops::SubAssign<i128> for Frac {",
      "    fn sub_assign(&mut self, z: i128) {",
      "        *self += -z;",
      "    }",
      "}",
      "impl std::ops::Mul<i128> for Frac {",
      "    type Output = Self;",
      "    fn mul(self, z: i128) -> Self {",
      "        Self::new(self.0 * z, self.1)",
      "    }",
      "}",
      "impl std::ops::Mul for Frac {",
      "    type Output = Self;",
      "    fn mul(self, other: Self) -> Self {",
      "        let numerator = self.0 * other.0;",
      "        let denominator = self.1 * other.1;",
      "        Self::new(numerator, denominator)",
      "    }",
      "}",
      "impl std::ops::MulAssign<i128> for Frac {",
      "    fn mul_assign(&mut self, z: i128) {",
      "        self.0 *= z;",
      "        self.normalize();",
      "    }",
      "}",
      "impl std::ops::Div for Frac {",
      "    type Output = Self;",
      "    fn div(self, other: Self) -> Self {",
      "        Self::new(self.0 * other.1, self.1 * other.0)",
      "    }",
      "}",
      "impl std::ops::Div<i128> for Frac {",
      "    type Output = Self;",
      "    fn div(self, other: i128) -> Self {",
      "        Self::new(self.0, self.1 * other)",
      "    }",
      "}",
      "impl std::ops::DivAssign<i128> for Frac {",
      "    fn div_assign(&mut self, z: i128) {",
      "        self.1 *= z;",
      "        self.normalize();",
      "    }",
      "}",
      "impl PartialOrd for Frac {",
      "    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
      "        use std::cmp::Ordering::*;",
      "        if self.1 == 0 && other.1 == 0 {",
      "            return Some(self.0.cmp(&other.0));",
      "        }",
      "        if self.1 == 0 {",
      "            return Some(if self.0 > 0 { Greater } else { Less });",
      "        }",
      "        if other.1 == 0 {",
      "            return Some(if other.0 > 0 { Less } else { Greater });",
      "        }",
      "        let lhs = self.0 * other.1;",
      "        let rhs = other.0 * self.1;",
      "        Some(lhs.cmp(&rhs))",
      "    }",
      "}",
      "impl Ord for Frac {",
      "    fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
      "        self.partial_cmp(&other).unwrap()",
      "    }",
      "}",
      "",
      "impl PartialEq for Frac {",
      "    fn eq(&self, other: &Self) -> bool {",
      "        self.0 == other.0 && self.1 == other.1",
      "    }",
      "}"
    ],
    "description": "Fraction struct with arithmetic and comparison operators implemented"
  },
  "_hash_value_program": {
    "prefix": "_hash_value_program",
    "body": [
      "const MOD:isize = 214783647;",
      "fn hash_value(l:usize, r:usize, h:&Vec<isize>, p:&Vec<isize>) -> Option<isize> {",
      "    if r + 1 < l {",
      "        return None;",
      "    }",
      "    let mut v = h[r + 1] - (h[l] * p[r - l + 1] % MOD);",
      "    if v < 0 {",
      "        v += MOD;",
      "    };",
      "    Some(v)",
      "}",
      "",
      "fn main() {",
      "    input! {",
      "        (n, q): (usize, usize),",
      "        s: Chars,",
      "    }",
      "    let mut p = vec![];",
      "    p.push(1);",
      "    for i in 1..=n {",
      "        p.push(100 * p[i - 1] % MOD);",
      "    }",
      "    let mut t = vec![];",
      "    for c in s {",
      "        t.push(c as isize - 'a' as isize + 1);",
      "    }",
      "    let mut h = vec![];",
      "    h.push(0);",
      "    for i in 1..=n {",
      "        h.push((100 * h[i - 1] + t[i - 1]) % MOD);",
      "    }",
      "    for _i in 0..q {",
      "        input! {(a, b, c, d): (Usize1, Usize1, Usize1, Usize1)}",
      "        let hash1 = hash_value(a, b, &h, &p);",
      "        let hash2 = hash_value(c, d, &h, &p);",
      "        let ans = if hash1 == hash2 { \"Yes\" } else { \"No\" };",
      "        println!(\"{}\", ans);",
      "    }",
      "}"
    ],
    "description": "String hash comparison using rolling hash"
  },
  "_henkaku_sort": {
    "prefix": "_henkaku_sort",
    "body": [
      "use ordered_float::OrderedFloat;",
      "#[derive(Debug, Clone, Copy)]",
      "pub struct Point {",
      "    pub x: f64,",
      "    pub y: f64",
      "}",
      "",
      "impl Point {",
      "    pub fn new(x: f64, y: f64) -> Self {",
      "        Self {x, y}",
      "    }",
      "",
      "    pub fn degree_from(&self, rhs: &Self) -> f64 {",
      "        let (cx, cy) = (rhs.x, rhs.y);",
      "        let r = ((cx - self.x).powi(2) + (cy - self.y).powi(2)).sqrt();",
      "        let x = cx - self.x;",
      "        let y = cy - self.y;",
      "        let rad =  (x / r).acos();",
      "        let deg = rad * 180. / std::f64::consts::PI;",
      "        let rev = 360. - deg;",
      "        if y >= 0. {deg} else {rev}",
      "    }",
      "}",
      "",
      "impl std::ops::Sub for Point {",
      "    type Output = Self;",
      "    fn sub(self, rhs: Self) -> Self::Output {",
      "        let x = rhs.x - self.x;",
      "        let y = rhs.y - self.y;",
      "        Self {x, y}",
      "    }",
      "}",
      "",
      "fn henkaku_btreeset(points: Vec<Point>, base_idx: usize) -> BTreeSet<(OrderedFloat<f64>, usize)> {",
      "    let mut set = BTreeSet::new();",
      "    for i in 0..points.len() {",
      "        if i == base_idx {",
      "            continue;",
      "        }",
      "        let deg = points[base_idx].degree_from(&points[i]);",
      "        let deg: OrderedFloat<f64> = OrderedFloat::from_f64(deg).unwrap();",
      "        set.insert((deg, i));",
      "    }",
      "    set",
      "}"
    ],
    "description": "偏角ソート"
  },
  "_hutarigumi_dfs": {
    "prefix": "_hutarigumi_dfs",
    "body": [
      "fn hutarigumi_dfs(set: &mut HashSet<usize>, ans: &mut Vec<Vec<(usize, usize)>>, now: &mut Vec<(usize, usize)>) {",
      "    let set_c = set.clone().into_iter().collect_vec();",
      "    let first = set_c[0];",
      "    set.remove(&first);",
      "    for &num in set_c.iter() {",
      "        set.remove(&num);",
      "        now.push((first, num));",
      "        if set.len() == 0 {",
      "            ans.push(now.to_vec());",
      "            now.pop();",
      "            set.insert(first);",
      "            set.insert(num);",
      "            return;",
      "        }",
      "        dfs(set, ans, now);",
      "        set.insert(num);",
      "        now.pop();",
      "    }",
      "    set.insert(first);",
      "}"
    ],
    "description": "DFS function for pairing elements in a set"
  },
  "_is_chokusen": {
    "prefix": "_is_chokusen",
    "body": [
      "fn is_chokusen<T: Clone + Copy + num_integer::Integer>(a: (T, T), b: (T, T), c: (T, T)) -> bool {",
      "    let mut v = vec![a, b, c];",
      "    v.sort_by_key(|&e| e.0);",
      "    let (a, b, c) = (v[0], v[1], v[2]);",
      "    let dx1 = b.0 - a.0;",
      "    let dx2 = c.0 - a.0;",
      "    let dy1 = b.1 - a.1;",
      "    let dy2 = c.1 - a.1;",
      "    dx2 * dy1 == dx1 * dy2",
      "}",
      "",
      "fn line_from_points<T: Clone + Copy + num_integer::Integer + num_traits::Signed>(p1: (T, T), p2: (T, T)) -> Option<(T, T, T)> {",
      "    let (x1, y1) = p1;",
      "    let (x2, y2) = p2;",
      "",
      "    if x1 == x2 && y1 == y2 {",
      "        return None;",
      "    }",
      "",
      "    let mut a = y1 - y2;",
      "    let mut b = x2 - x1;",
      "    let mut c = x1 * y2 - x2 * y1;",
      "",
      "",
      "    let g = gcd(a.abs(), b.abs()).gcd(&c.abs());",
      "    if !g.is_zero() {",
      "        a = a / g;",
      "        b = b / g;",
      "        c = c / g;",
      "    }",
      "",
      "    let zero = T::zero();",
      "    if a < zero || (a == zero && b < zero) || (a == zero && b == zero && c < zero) {",
      "        a = -a;",
      "        b = -b;",
      "        c = -c;",
      "    }",
      "",
      "    Some((a, b, c))",
      "}"
    ]
  },
  "_is_prime_miller": {
    "prefix": "_is_prime_miller",
    "body": [
      "fn is_prime_miller(n: u64) -> bool {",
      "    if n <= 1 {",
      "        return false;",
      "    } else if n <= 3 {",
      "        return true;",
      "    } else if n % 2 == 0 {",
      "        return false;",
      "    }",
      "    let pow = |r: u64, mut m: u64| -> u64 {",
      "        let mut t = 1u128;",
      "        let mut s = (r % n) as u128;",
      "        let n = n as u128;",
      "        while m > 0 {",
      "            if m & 1 == 1 {",
      "                t = t * s % n;",
      "            }",
      "            s = s * s % n;",
      "            m >>= 1;",
      "        }",
      "        t as u64",
      "    };",
      "    let mut d = n - 1;",
      "    let mut s = 0;",
      "    while d % 2 == 0 {",
      "        d /= 2;",
      "        s += 1;",
      "    }",
      "    const B: [u64; 7] = [2, 325, 9375, 28178, 450775, 9780504, 1795265022];",
      "    for &b in B.iter() {",
      "        let mut a = pow(b, d);",
      "        if a <= 1 {",
      "            continue;",
      "        }",
      "        let mut i = 0;",
      "        while i < s && a != n - 1 {",
      "            i += 1;",
      "            a = (a as u128 * a as u128 % n as u128) as u64;",
      "        }",
      "        if i >= s {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}"
    ],
    "description": "Miller-Rabin primality test"
  },
  "_isize_ceil": {
    "prefix": "_isize_ceil",
    "body": [
      "fn isize_ceil(a: isize, b: isize) -> isize {",
      "    if (a + b - 1 < 0) && (a + b - 1) % b != 0 {",
      "        return (a + b - 1)/ b - 1;",
      "    }",
      "    return (a + b - 1) / b;",
      "}"
    ],
    "description": "Function to calculate isize ceil"
  },
  "_isize_floor_div": {
    "prefix": "_isize_floor_div",
    "body": [
      "fn isize_floor_div(x: isize, m: isize) -> isize {",
      "    let r = (x % m + m) % m;",
      "    (x - r) / m",
      "}"
    ],
    "description": "Function to calculate isize floor division"
  },
  "_itertools": {
    "prefix": "_itertools",
    "body": [
      "pub trait CollectVec: Iterator + Sized {",
      "    fn collect_vec(self) -> Vec<Self::Item>;",
      "}",
      "impl<I: Iterator> CollectVec for I {",
      "    fn collect_vec(self) -> Vec<Self::Item> {",
      "        self.collect()",
      "    }",
      "}",
      "",
      "pub trait Joiner {",
      "    fn join(self, sep: &str) -> String;",
      "}",
      "",
      "impl<T: ToString, I: IntoIterator<Item = T>> Joiner for I {",
      "    fn join(self, sep: &str) -> String {",
      "        self.into_iter()",
      "            .map(|x| x.to_string())",
      "            .collect::<Vec<_>>()",
      "            .join(sep)",
      "    }",
      "}"
    ]
  },
  "_kousa": {
    "prefix": "_kousa",
    "body": [
      "type P = (usize, usize);",
      "",
      "fn sign(v: isize) -> i32 {",
      "    if v > 0 { 1 } else if v < 0 { -1 } else { 0 }",
      "}",
      "",
      "/// 3点 a,b,c の向き: 反時計回り=1, 時計回り=-1, 直線上=0",
      "pub(crate) fn orientation(a: P, b: P, c: P) -> i32 {",
      "    let (ax, ay) = (a.0 as isize, a.1 as isize);",
      "    let (bx, by) = (b.0 as isize, b.1 as isize);",
      "    let (cx, cy) = (c.0 as isize, c.1 as isize);",
      "",
      "    let cross = (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);",
      "    sign(cross)",
      "}",
      "",
      "/// 2線分 [p1,p2] と [q1,q2] が交差（端点接触・重なりを含む）するか",
      "pub(crate) fn segments_intersect(p1: P, p2: P, q1: P, q2: P) -> bool {",
      "    // 軸平行のバウンディングボックスで早期除外",
      "    if max(p1.0, p2.0) < min(q1.0, q2.0)",
      "        || max(q1.0, q2.0) < min(p1.0, p2.0)",
      "        || max(p1.1, p2.1) < min(q1.1, q2.1)",
      "        || max(q1.1, q2.1) < min(p1.1, p2.1)",
      "    {",
      "        return false;",
      "    }",
      "",
      "    let o1 = orientation(p1, p2, q1);",
      "    let o2 = orientation(p1, p2, q2);",
      "    let o3 = orientation(q1, q2, p1);",
      "    let o4 = orientation(q1, q2, p2);",
      "",
      "    (o1 * o2 <= 0) && (o3 * o4 <= 0)",
      "}",
      "",
      "",
      ""
    ],
    "description": "交差判定"
  },
  "_manhattan": {
    "prefix": "_manhattan",
    "body": [
      "fn replace_manhattan_coord(xy: (isize, isize)) -> (isize, isize) {",
      "    let (x, y) = xy;",
      "    (x - y, x + y)",
      "}",
      ""
    ],
    "description": "45deg回転"
  },
  "_mat_pow": {
    "prefix": "_mat_pow",
    "body": [
      "type Mat = Vec<Vec<ModInt1000000007>>;",
      "",
      "fn mul(a: &Mat, b: &Mat) -> Mat {",
      "    let n = a.len();",
      "    let mut c = vec![vec![ModInt1000000007::new(0); n]; n];",
      "    for i in 0..n {",
      "        for k in 0..n {",
      "            if a[i][k].val() == 0 { continue; }",
      "            let aik = a[i][k];",
      "            for j in 0..n {",
      "                c[i][j] = c[i][j] + aik * b[k][j];",
      "            }",
      "        }",
      "    }",
      "    c",
      "}",
      "",
      "fn mat_pow(mut base: Mat, mut k: u128) -> Mat {",
      "    let n = base.len();",
      "    let mut res = vec![vec![ModInt1000000007::new(0); n]; n];",
      "    for i in 0..n { res[i][i] += 1; }",
      "",
      "    while k > 0 {",
      "        if k & 1 == 1 {",
      "            res = mul(&res, &base);",
      "        }",
      "        base = mul(&base, &base);",
      "        k >>= 1;",
      "    }",
      "    res",
      "}"
    ],
    "description": "行列累乗（ModInt1000000007 用）"
  },
  "_matrix_kake": {
    "prefix": "_matrix_kake",
    "body": [
      "fn multiply_matrices<T: std::ops::Mul<Output = T> + std::iter::Sum + Copy + Default>(a: &Vec<Vec<T>>, b: &Vec<Vec<T>>) -> Option<Vec<Vec<T>>> {",
      "    if a[0].len() != b.len() {",
      "        return None;",
      "    }",
      "    let rows = a.len();",
      "    let cols = b[0].len();",
      "    let common_dim = a[0].len();",
      "",
      "    let mut result = vec![vec![T::default(); cols]; rows];",
      "",
      "    for i in 0..rows {",
      "        for j in 0..cols {",
      "            result[i][j] = (0..common_dim).map(|k| a[i][k] * b[k][j]).sum();",
      "        }",
      "    }",
      "    Some(result)",
      "}"
    ],
    "description": "A function to multiply two 2D matrices in Rust using generics."
  },
  "_mod_nck_9982": {
    "prefix": "_nck_mod",
    "body": [
      "type Mint = ModInt1000000007;",
      "pub struct Comb {",
      "    pub fact: Vec<Mint>,",
      "    pub ifact: Vec<Mint>,",
      "}",
      "",
      "impl Comb {",
      "    pub fn new(nmax: usize) -> Self {",
      "        let mut fact = vec![Mint::new(1); nmax + 1];",
      "        let mut ifact = vec![Mint::new(0); nmax + 1];",
      "        for i in 1..=nmax {",
      "            fact[i] = fact[i - 1] * i;",
      "        }",
      "        ifact[nmax] = fact[nmax].inv();",
      "        for i in (1..=nmax).rev() {",
      "            ifact[i - 1] = ifact[i] * i;",
      "        }",
      "        Self {",
      "            fact,",
      "            ifact",
      "        }",
      "    }",
      "",
      "    pub fn nck(&self, n: usize, k: usize) -> Mint {",
      "        if n < k {",
      "            return Mint::new(0);",
      "        }",
      "        return self.fact[n] * self.ifact[k] * self.ifact[n - k];",
      "    }",
      "}"
    ],
    "description": "Generates factorial and comb functions using ModInt998244353 for modular arithmetic."
  },
  "_modpow": {
    "prefix": "_modpow",
    "body": [
      "fn mod_pow(mut x: usize, mut n: usize, m: usize) -> usize {",
      "    x %= m;",
      "    let mut ans = 1;",
      "    while n != 0 {",
      "        if n.is_odd() {",
      "            ans = ans * x % m;",
      "        }",
      "        x = x * x % m;",
      "        n >>= 1;",
      "    }",
      "    ans",
      "}"
    ],
    "description": "Calculates (x^n) % m efficiently using binary exponentiation."
  },
  "_nc2": {
    "prefix": "_nc2",
    "body": [
      "let nc2 = |n: usize| {",
      "    if n <= 1 {",
      "        return 0;",
      "    }",
      "    n * (n - 1) / 2",
      "};"
    ],
    "description": "nc2 calculation"
  },
  "_nc3": {
    "prefix": "_nc3",
    "body": [
      "let nc3 = |n: usize| {",
      "    if n <= 2 {",
      "        return 0;",
      "    }",
      "    n * (n - 1) * (n - 2) / 6",
      "};"
    ],
    "description": "nc3 calculation"
  },
  "_nck": {
    "prefix": "_nck",
    "body": [
      "fn nck(n: u128, k: u128) -> u128 {",
      "    if k > n {",
      "        return 0;",
      "    }",
      "",
      "    let k = if k > n - k { n - k } else { k };",
      "",
      "    let mut result = 1;",
      "    for i in 0..k {",
      "        result = result * (n - i) / (i + 1);",
      "    }",
      "",
      "    result",
      "}"
    ],
    "description": "Function to calculate binomial coefficient (n choose k)"
  },
  "_ordered_set": {
    "prefix": "_ordered_set",
    "body": [
      "use ordered_set::OrderedSet;",
      "pub mod ordered_set {",
      "    use ac_library::FenwickTree;",
      "    use num_traits::Bounded;",
      "    use std::{collections::{BTreeSet, HashMap}, hash::Hash};",
      "",
      "    pub struct OrderedSet<T: Ord + Hash + Copy + Bounded> {",
      "        id_map: HashMap<T, usize>,",
      "        inv: Vec<T>,",
      "        id_max: usize,",
      "        fen: FenwickTree<isize>,",
      "        set: BTreeSet<T>,",
      "    }",
      "",
      "    impl<T: Ord + Hash + Copy + Bounded> OrderedSet<T> {",
      "        /// 使う数字すべて入力する。(座圧のため。しなくて良い場合は0..=nとか入力しといて。)sort, dedupしてなくてもOK。なにもinsertしないよ",
      "        pub fn new(vec_nums: &Vec<T>) -> Self {",
      "            let mut v = vec_nums.to_owned();",
      "            v.sort();",
      "            v.dedup();",
      "            let mut id = 0;",
      "            let mut id_map = HashMap::new();",
      "            for &num in v.iter() {",
      "                id_map.insert(num, id);",
      "                id += 1usize;",
      "            }",
      "            let mut inv = vec![T::max_value(); id];",
      "            let fen = FenwickTree::new(id + 5, 0);",
      "            for &num in v.iter() {",
      "                let &id = id_map.get(&num).unwrap();",
      "                inv[id] = num;",
      "            }",
      "            Self {",
      "                id_map,",
      "                inv,",
      "                id_max: id,",
      "                fen,",
      "                set: BTreeSet::new(),",
      "            }",
      "        }",
      "",
      "        pub fn insert(&mut self, num: T) -> bool {",
      "            let id = self.get_id(num);",
      "            self.set.insert(num);",
      "            let c = self.fen.sum(id..=id);",
      "            assert!(c <= 1);",
      "            if c == 1 {",
      "                return false;",
      "            }",
      "            assert!(c == 0);",
      "            self.fen.add(id, 1);",
      "            true",
      "        }",
      "        pub fn remove(&mut self, num: T) -> bool {",
      "            let id = self.get_id(num);",
      "            self.set.remove(&num);",
      "            let c = self.fen.sum(id..=id);",
      "            assert!(c <= 1);",
      "            if c == 0 {",
      "                return false;",
      "            }",
      "            assert!(c == 1);",
      "            self.fen.add(id, -1);",
      "            true",
      "        }",
      "",
      "        /// \\[start, end\\] 内に要素が何個あるかを調べる",
      "        pub fn range_count(&self, start: T, end: T) -> usize {",
      "            let set = self.set();",
      "            let rr = set.range(start..).next();",
      "            let ll = set.range(..=end).next_back();",
      "            if rr.is_none() {",
      "                return 0;",
      "            }",
      "            if ll.is_none() {",
      "                return 0;",
      "            }",
      "            let &low = rr.unwrap();",
      "            let &top = ll.unwrap();",
      "",
      "            let start = self.get_id(low);",
      "            let end = self.get_id(top);",
      "            return self.fen.sum(start..=end) as usize;",
      "        }",
      "",
      "        /// 昇順n番目の要素を取得する。0-indexed",
      "        pub fn get_nth(&self, n: usize) -> Option<T> {",
      "            let c = n + 1;",
      "            let first = self.fen.sum(0..=0) as usize;",
      "            if first >= c {",
      "                return Some(self.inv[0]);",
      "            }",
      "            let tot = self.fen.sum(..) as usize;",
      "            if c > tot {",
      "                return None;",
      "            }",
      "            let mut left = 0;",
      "            let mut right = self.id_max;",
      "",
      "            while right - left > 1 {",
      "                let mid = (left + right) / 2;",
      "                let now = self.fen.sum(0..=mid) as usize;",
      "                if now >= c {",
      "                    right = mid;",
      "                } else {",
      "                    left = mid;",
      "                }",
      "            }",
      "            Some(self.inv[right])",
      "        }",
      "",
      "        /// S の x以下の要素のうち最大のもの, x以上最小とかはBTreesetから入手するが、めんどくさいからgetterで渡して出してもらいます",
      "        pub fn set(&self) -> &BTreeSet<T> {",
      "            &self.set",
      "        }",
      "",
      "        pub fn get_id(&self, num: T) -> usize {",
      "            let &id = self.id_map.get(&num).unwrap();",
      "            id",
      "        }",
      "        pub fn max_id(&self) -> usize {",
      "            self.id_max",
      "        }",
      "    }",
      "}"
    ]
  },
  "_potentialunionfind": {
    "prefix": "_potential_union_find",
    "body": [
      "pub struct PotentialUnionFind {",
      "    rank: Vec<usize>,",
      "    parent: Vec<usize>,",
      "    size: Vec<usize>,",
      "    diff_weight: Vec<isize>,",
      "}",
      "impl PotentialUnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        let rank = vec![0; n];",
      "        let parent = (0..n).collect::<Vec<_>>();",
      "        let size = vec![1; n];",
      "        let diff_weight = vec![0; n];",
      "        PotentialUnionFind { rank, parent, size, diff_weight }",
      "    }",
      "",
      "    pub fn leader(&mut self, n: usize) -> usize {",
      "        if self.parent[n] == n {",
      "            n",
      "        } else {",
      "            let r = self.leader(self.parent[n]);",
      "            self.diff_weight[n] += self.diff_weight[self.parent[n]];",
      "            self.parent[n] = r;",
      "            r",
      "        }",
      "    }",
      "",
      "    pub fn weight(&mut self, n: usize) -> isize {",
      "        self.leader(n);",
      "        self.diff_weight[n]",
      "    }",
      "",
      "    pub fn merge(&mut self, a: usize, b: usize, w: isize) {",
      "        let w = w + self.weight(a) - self.weight(b);",
      "        let a = self.leader(a);",
      "        let b = self.leader(b);",
      "        if a == b {",
      "            return;",
      "        }",
      "        if self.rank[a] < self.rank[b] {",
      "            self.parent[a] = b;",
      "            self.size[b] += self.size[a];",
      "            self.diff_weight[a] = -w;",
      "        } else {",
      "            self.parent[b] = a;",
      "            self.size[a] += self.size[b];",
      "            if self.rank[a] == self.rank[b] {",
      "                self.rank[a] += 1;",
      "            }",
      "            self.diff_weight[b] = w;",
      "        }",
      "    }",
      "",
      "    pub fn diff(&mut self, a: usize, b: usize) -> isize {",
      "        self.weight(b) - self.weight(a)",
      "    }",
      "",
      "    pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "        self.leader(a) == self.leader(b)",
      "    }",
      "",
      "    pub fn size(&mut self, n: usize) -> usize {",
      "        let leader = self.leader(n);",
      "        return self.size[leader];",
      "    }",
      "}"
    ],
    "description": "Potential Union-Find data structure implementation in Rust."
  },
  "_prefix_sum_1d": {
    "prefix": "_prefix_sum_1d",
    "body": [
      "use num_traits::Zero;",
      "use std::ops::{Add, Sub, Bound, Range, RangeBounds};",
      "",
      "#[derive(Clone, Debug, PartialEq, Eq)]",
      "pub struct PrefixSum1D<T> {",
      "    acc: Vec<T>,",
      "}",
      "",
      "impl<T> PrefixSum1D<T>",
      "where",
      "    T: Zero + Clone + Copy + Add<Output = T> + Sub<Output = T>,",
      "{",
      "    pub fn new(xs: &[T]) -> Self {",
      "        let mut acc  = vec![T::zero()];",
      "        for &x in xs.iter() {",
      "            let &la = acc.last().unwrap();",
      "            acc.push(la + x);",
      "        }",
      "        Self { acc }",
      "    }",
      "",
      "    pub fn acc(&self) -> &Vec<T> {",
      "        &self.acc",
      "    }",
      "",
      "    // rangeの和",
      "    pub fn range_sum(&self, range: impl RangeBounds<usize>) -> T {",
      "        let range = self.get_range(range);",
      "        let end = self.acc[range.end];",
      "        let start = self.acc[range.start];",
      "        end - start",
      "    }",
      "",
      "    /// 区間 [0, end) の和",
      "    pub fn prefix_sum(&self, end: usize) -> T {",
      "        self.acc[end]",
      "    }",
      "",
      "    /// 区間 [begin, n) の和",
      "    pub fn suffix_sum(&self, begin: usize) -> T {",
      "        let n = self.acc.len() - 1;",
      "        let total = self.acc[n];",
      "        total - self.acc[begin]",
      "    }",
      "",
      "    /// 全要素の和",
      "    pub fn total_sum(&self) -> T {",
      "        let &la = self.acc.last().unwrap_or(&T::zero());",
      "        la",
      "    }",
      "",
      "    /// f(sum(l..r)) が true となる最大の r in [l, n] を二分探索で探す。",
      "    ///",
      "    /// 条件:",
      "    /// - f(0) は true",
      "    /// - r が増えるといつか false になり、その後はずっと false（単調）",
      "    ///",
      "    /// O(log n)",
      "    pub fn max_right<F>(&self, l: usize, mut f: F) -> usize",
      "    where",
      "        F: FnMut(T) -> bool,",
      "    {",
      "        let n = self.acc.len();",
      "        assert!(l <= n);",
      "        assert!(f(T::zero()), \"f(0) must be true\");",
      "",
      "        if f(self.range_sum(l..n)) {",
      "            return n;",
      "        }",
      "",
      "        let mut ok = l;",
      "        let mut ng = n + 1;",
      "        while ng - ok > 1 {",
      "            let mid = ok + (ng - ok) / 2;",
      "            if f(self.range_sum(l..mid)) {",
      "                ok = mid;",
      "            } else {",
      "                ng = mid;",
      "            }",
      "        }",
      "        ok",
      "    }",
      "",
      "    /// f(sum(l..r)) が true となる最小の l in [0, r] を二分探索で探す。",
      "    ///",
      "    /// 条件:",
      "    /// - f(0) は true",
      "    /// - l を右に動かしていくと、ある地点からずっと true（単調）",
      "    ///",
      "    /// O(log r)",
      "    pub fn min_left<F>(&self, r: usize, mut f: F) -> usize",
      "    where",
      "        F: FnMut(T) -> bool,",
      "    {",
      "        let n = self.acc().len();",
      "        assert!(r <= n);",
      "        assert!(f(T::zero()), \"f(0) must be true\");",
      "",
      "        if f(self.range_sum(0..r)) {",
      "            return 0;",
      "        }",
      "",
      "        let mut ok = r;",
      "        let mut ng = 0;",
      "        while ok - ng > 1 {",
      "            let mid = ng + (ok - ng) / 2;",
      "            if f(self.range_sum(mid..r)) {",
      "                ok = mid;",
      "            } else {",
      "                ng = mid;",
      "            }",
      "        }",
      "        ok",
      "    }",
      "",
      "    fn get_range(&self, range: impl RangeBounds<usize>) -> Range<usize> {",
      "        let begin = match range.start_bound() {",
      "            Bound::Unbounded => 0,",
      "            Bound::Included(&x) => x,",
      "            Bound::Excluded(&x) => x + 1,",
      "        };",
      "        let end = match range.end_bound() {",
      "            Bound::Excluded(&x) => x,",
      "            Bound::Included(&x) => x + 1,",
      "            Bound::Unbounded => self.acc.len() - 1,",
      "        };",
      "        begin..end",
      "    }",
      "}",
      ""
    ]
  },
  "_product_repeat": {
    "prefix": "_product_repeat",
    "body": [
      "pub trait ProductRepeat: Iterator + Clone",
      "where",
      "    Self::Item: Clone,",
      "{",
      "    fn product_repeat(self, repeat: usize) -> MultiProduct<Self> {",
      "        std::iter::repeat(self).take(repeat).multi_cartesian_product()",
      "    }",
      "}",
      "",
      "impl<T: Iterator + Clone> ProductRepeat for T where T::Item: Clone {}"
    ],
    "description": "Trait for repeating product cartesian"
  },
  "_quickfind": {
    "prefix": "_quickfind",
    "body": [
      "pub struct QuickFind {",
      "    leader: Vec<usize>,",
      "    members: Vec<Vec<usize>>,",
      "    diff: Vec<i64>,",
      "}",
      "impl QuickFind {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            leader: (0..n).collect(),",
      "            members: (0..n).map(|i| vec![i]).collect(),",
      "            diff: vec![0; n],",
      "        }",
      "    }",
      "",
      "    pub fn union(&mut self, i: usize, j: usize, d: i64) -> Result<(), ()> {",
      "        let d = d + self.diff[j] - self.diff[i];",
      "        let i = self.leader[i];",
      "        let j = self.leader[j];",
      "        if i == j {",
      "            return (d == 0).then_some(()).ok_or(());",
      "        }",
      "        if self.members[i].len() < self.members[j].len() {",
      "            for &k in &self.members[i] {",
      "                self.leader[k] = self.leader[j];",
      "                self.diff[k] += d;",
      "            }",
      "            let members = std::mem::take(&mut self.members[i]);",
      "            self.members[j].extend(members);",
      "        } else {",
      "            for &k in &self.members[self.leader[j]] {",
      "                self.leader[k] = self.leader[i];",
      "                self.diff[k] -= d;",
      "            }",
      "            let members = std::mem::take(&mut self.members[j]);",
      "            self.members[i].extend(members);",
      "        }",
      "        Ok(())",
      "    }",
      "}"
    ],
    "description": "QuickFind data structure implementation in Rust."
  },
  "_rerooting": {
    "prefix": "_rerooting",
    "body": [
      "fn rerooting<",
      "    T: Clone,",
      "    E: IntoIterator<Item = (usize, usize)>,",
      "    F: FnMut(T, T) -> T,",
      "    G: FnMut(T, usize) -> T,",
      ">(",
      "    node_count: usize,",
      "    edges: E,",
      "    identity: T,",
      "    mut merge_operate: F,",
      "    mut operate_node: G,",
      ") -> Vec<T> {",
      "    const NO_PARENT: usize = std::usize::MAX;",
      "    //to[i] := 隣接している頂点の配列",
      "    let mut to = vec![vec![]; node_count];",
      "    //index_to[i][j] := adjacents[i][j](iのj番目の隣接頂点)にとって、iが何番目の隣接頂点か",
      "    let mut index_to = vec![vec![]; node_count];",
      "",
      "    for (u, v) in edges {",
      "        index_to[u].push(to[v].len());",
      "        index_to[v].push(to[u].len());",
      "        to[u].push(v);",
      "        to[v].push(u);",
      "    }",
      "",
      "    if node_count == 0 {",
      "        return vec![];",
      "    }",
      "",
      "    if node_count == 1 {",
      "        return vec![operate_node(identity, 0)];",
      "    }",
      "    //parents[i] := 一時的な根付き木として考えた時の、ノードiについての親",
      "    let mut parents = vec![0; node_count];",
      "    // order: BFS などで深さ順に並べた配列 (親が先・子が後)",
      "    // この配列を深さの大きい順(後ろから)に処理することで",
      "    // 「子が先、親が後」の計算順序を満たす",
      "    // 厳密には行きがけじゅんじゃないよ",
      "    let mut order = vec![0; node_count];",
      "",
      "    // initialize ordered tree",
      "    // BFSして頂点0(1頂点から)のみの答えをとりあえず出す",
      "    // 「子が先、親が後」の計算順序を満たす",
      "    // 厳密には行きがけじゅんじゃないよ",
      "    {",
      "        let mut count = 0;",
      "        let mut stack = vec![0];",
      "        parents[0] = NO_PARENT;",
      "",
      "        while let Some(v) = stack.pop() {",
      "            order[count] = v;",
      "            count += 1;",
      "",
      "            for &v2 in to[v].iter() {",
      "                if v2 == parents[v] {",
      "                    continue;",
      "                }",
      "                stack.push(v2);",
      "                parents[v2] = v;",
      "            }",
      "        }",
      "    }",
      "",
      "    // dp[i][j] := 「親 = i、子 = to[i][j]」と見なしたときの部分木の DP 値",
      "    let mut dp = (0..node_count)",
      "        .map(|i| vec![identity.clone(); to[i].len()])",
      "        .collect::<Vec<_>>();",
      "    // from leaf",
      "    for i in (1..node_count).rev() {",
      "        // 今みている頂点",
      "        // order[count] = v;としているのでこれで子から親へが約束される",
      "        let node = order[i];",
      "        // その親",
      "        let parent = parents[node];",
      "",
      "        // 子方向から集めた値を accumulate する",
      "        let mut accum = identity.clone();",
      "        let mut parent_index = NO_PARENT;",
      "",
      "        for j in 0..to[node].len() {",
      "            if to[node][j] == parent {",
      "                parent_index = j;",
      "                continue;",
      "            }",
      "",
      "            // 子方向から集めた値を accumulate する",
      "            accum = merge_operate(accum, dp[node][j].to_owned());",
      "        }",
      "",
      "        dp[parent][index_to[node][parent_index]] = operate_node(accum, node);",
      "    }",
      "",
      "    let mut res = vec![identity.clone(); node_count];",
      "    let mut accums_from_tail = vec![];",
      "",
      "    // to leaf",
      "    for i in 0..node_count {",
      "        let node = order[i];",
      "        let deg = to[node].len();",
      "        let mut accum = identity.clone();",
      "",
      "        accums_from_tail.clear();",
      "        accums_from_tail.extend(std::iter::repeat(identity.clone()).take(deg));",
      "",
      "        for j in (1..deg).rev() {",
      "            accums_from_tail[j - 1] = merge_operate(accums_from_tail[j].clone(), dp[node][j].clone());",
      "        }",
      "",
      "        for j in 0..deg {",
      "            dp[to[node][j]][index_to[node][j]] =",
      "                operate_node(merge_operate(accum.clone(), accums_from_tail[j].clone()), node);",
      "            accum = merge_operate(accum, dp[node][j].clone());",
      "        }",
      "",
      "        res[node] = operate_node(accum, node);",
      "    }",
      "",
      "    res",
      "}"
    ],
    "description": "Rerooting DP function with detailed comments in Rust"
  },
  "_rotate_90_degrees": {
    "prefix": "_rotate_90_degrees",
    "body": [
      "fn rotate_90_degrees<T: Clone>(matrix: Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    let rows = matrix.len();",
      "    let cols = matrix[0].len();",
      "    let mut rotated = vec![vec![matrix[0][0].clone(); rows]; cols];",
      "",
      "    for i in 0..rows {",
      "        for j in 0..cols {",
      "            rotated[j][rows - i - 1] = matrix[i][j].clone();",
      "        }",
      "    }",
      "",
      "    rotated",
      "}"
    ],
    "description": "Function to rotate a matrix 90 degrees clockwise"
  },
  "_round": {
    "prefix": "_round",
    "body": [
      "fn round(x: usize, i: u32) -> usize {",
      "    let ip = 10usize.pow(i + 1);",
      "    let ii = 10usize.pow(i);",
      "    ((x + 5 * ii) / ip) * ip",
      "}"
    ],
    "description": "round"
  },
  "_scanner": {
    "prefix": "_scanner",
    "body": [
      "use std::{io::{stdin, Read}, str::FromStr};",
      "",
      "pub struct Scanner<I: Iterator<Item = char>> {",
      "    iter: std::iter::Peekable<I>,",
      "}",
      "",
      "macro_rules! exit {",
      "    () => {{",
      "        exit!(0)",
      "    }};",
      "    (\\$code:expr) => {{",
      "        std::process::exit(\\$code);",
      "    }}",
      "}",
      "",
      "impl<I: Iterator<Item = char>> Scanner<I> {",
      "    pub fn new(iter: I) -> Scanner<I> {",
      "        Scanner {",
      "            iter: iter.peekable(),",
      "        }",
      "    }",
      "",
      "    pub fn safe_get_token(&mut self) -> Option<String> {",
      "        let token = self.iter",
      "            .by_ref()",
      "            .skip_while(|c| c.is_whitespace())",
      "            .take_while(|c| !c.is_whitespace())",
      "            .collect::<String>();",
      "        if token.is_empty() {",
      "            None",
      "        } else {",
      "            Some(token)",
      "        }",
      "    }",
      "",
      "    pub fn token(&mut self) -> String {",
      "        self.safe_get_token().unwrap_or_else(|| exit!())",
      "    }",
      "",
      "    pub fn get<T: FromStr>(&mut self) -> T {",
      "        self.token().parse::<T>().unwrap_or_else(|_| exit!())",
      "    }",
      "",
      "    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {",
      "        (0..len).map(|_| self.get()).collect()",
      "    }",
      "",
      "    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {",
      "        (0..row).map(|_| self.vec(col)).collect()",
      "    }",
      "",
      "    pub fn char(&mut self) -> char {",
      "        self.iter.next().unwrap_or_else(|| exit!())",
      "    }",
      "",
      "    pub fn chars(&mut self) -> Vec<char> {",
      "        self.get::<String>().chars().collect()",
      "    }",
      "",
      "    pub fn line(&mut self) -> String {",
      "        if self.peek().is_some() {",
      "            self.iter",
      "                .by_ref()",
      "                .take_while(|&c| !(c == '\\n' || c == '\\r'))",
      "                .collect::<String>()",
      "        } else {",
      "            exit!();",
      "        }",
      "    }",
      "",
      "    pub fn peek(&mut self) -> Option<&char> {",
      "        self.iter.peek()",
      "    }",
      "}",
      "",
      "fn main() {",
      "    let cin = stdin().lock();",
      "    let mut sc = Scanner::new(cin.bytes().map(|e| e.unwrap() as char));",
      "    loop {",
      "        let w: usize = sc.get();",
      "        let h: usize = sc.get();",
      "    }",
      "}"
    ],
    "description": "Scanner struct for reading from stdin, useful for competitive programming."
  },
  "_shakutori_template": {
    "prefix": "_shakutori_template",
    "body": [
      "// let mut right: usize = 0;",
      "// for left in 0..n {",
      "//     // 右端を可能な限り伸ばす",
      "//     while right < n && /* (right を 1 個進めたときに条件を満たす) */ {",
      "//         // 実際に right を 1 進める",
      "//         // 例: sum += a[right];",
      "//         right += 1;",
      "//     }",
      "",
      "//     // ここに来た時点で right は条件を満たす最大値なので、何かする",
      "//     // 例: res += right - left;",
      "",
      "//     // left をインクリメントする準備",
      "//     if right == left {",
      "//         // 番兵的に right も 1 進める",
      "//         right += 1;",
      "//     } else {",
      "//         // ウィンドウから a[left] を外す",
      "//         // 例: sum -= a[left];",
      "//     }"
    ],
    "description": "尺取り法テンプレート"
  },
  "_sishagonyu": {
    "prefix": "_sishagonyu",
    "body": [
      "fn round_half_up(value: f64, digits: i32) -> f64 {",
      "    let factor = 10f64.powi(digits);",
      "    let abs = value.abs() * factor;",
      "    let rounded = (abs + 0.5).floor();",
      "    rounded.copysign(value) / factor",
      "}"
    ],
    "description": "f64 の値を指定桁数で round half up する関数スニペット"
  },
  "_soinsu_factorization": {
    "prefix": "_soinsu_factorization",
    "body": [
      "fn factorization(mut x: i64) -> Vec<(i64, i64)> {",
      "    let mut resu = Vec::new();",
      "    for i in 2.. {",
      "        if i*i > x { break; }",
      "        if x % i != 0 { continue; }",
      "",
      "        let mut e = 0;",
      "        while x % i == 0 {",
      "            e += 1;",
      "            x /= i;",
      "        }",
      "",
      "        resu.push((i, e));",
      "    }",
      "",
      "    if x != 1 {",
      "        resu.push((x, 1));",
      "    }",
      "",
      "    resu",
      "}"
    ],
    "description": "Function to perform prime factorization"
  },
  "_sqrt_nibutan": {
    "prefix": "_sqrt_nibutan",
    "body": [
      "fn sqrt_i128(v: i128) -> i128 {",
      "    let mut ok = 0;",
      "    let mut ng = v;",
      "    while ng - ok > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        if mid * mid <= v {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ],
    "description": "Function to compute the integer square root of an i128"
  },
  "_stringhash": {
    "prefix": "_stringhash",
    "body": [
      "struct StringHash {",
      "    modulo: u128,",
      "    len: usize,",
      "    h: Vec<u128>,",
      "    pow: Vec<u128>,",
      "}",
      "",
      "impl StringHash {",
      "    fn alpha_to_u64(c: char) -> Option<u128> {",
      "        match c {",
      "            'A'..='Z' => Some(c as u128 - 'A' as u128),",
      "            'a'..='z' => Some(c as u128 - 'a' as u128),",
      "            _ => None,",
      "        }",
      "    }",
      "",
      "    fn new(str: &str, mods: Option<u128>, base: Option<u128>) -> StringHash {",
      "        let modulo = mods.unwrap_or(2_147_483_647);",
      "        let base = base.unwrap_or(911382323) % modulo;",
      "        let len = str.len();",
      "        assert!(modulo >= 3, \"modulo は素数など十分大きい値を推奨\");",
      "        assert!(base != 0, \"base % modulo が 0 にならないようにする\");",
      "",
      "        // t[] の設定",
      "        let mut t = vec![0; len + 1];",
      "        for (i, c) in str.chars().enumerate() {",
      "            t[i + 1] = Self::alpha_to_u64(c).expect(\"文字列にはアルファベットのみが含まれる\");",
      "        }",
      "",
      "        // pow100[] の設定",
      "        let mut pow = vec![1; len + 1];",
      "        for i in 1..=len {",
      "            pow[i] = pow[i - 1] * base % modulo",
      "        }",
      "",
      "        // h[] の設定",
      "        let mut h = vec![0; len + 1];",
      "        for i in 1..=len {",
      "            h[i] = (base * h[i - 1] + t[i]) % modulo",
      "        }",
      "",
      "        Self {",
      "            modulo,",
      "            len,",
      "            h,",
      "            pow,",
      "        }",
      "    }",
      "",
      "    // String[l..=r]のハッシュ値(0-indexed)",
      "    fn hash(&self, l: usize, r: usize) -> u128 {",
      "        assert!(l <= r);",
      "        assert!(r < self.len);",
      "        let l1 = l + 1;",
      "        let r1 = r + 1;",
      "        (self.h[r1] + self.modulo - (self.h[l1 - 1] * self.pow[r1 - l1 + 1] % self.modulo))",
      "            % self.modulo",
      "    }",
      "}"
    ],
    "description": "StringHash: 文字列のハッシュを高速に求めるデータ構造（Rust）"
  },
  "_superslice": {
    "prefix": "_superslice",
    "body": [
      "pub mod superslice {",
      "    use core::cmp::Ordering::{self, Greater, Less};",
      "    pub trait Ext {",
      "        type Item;",
      "        fn lower_bound(&self, x: &Self::Item) -> usize",
      "        where",
      "            Self::Item: Ord;",
      "",
      "        fn lower_bound_by<'a, F>(&'a self, f: F) -> usize",
      "        where",
      "            F: FnMut(&'a Self::Item) -> Ordering;",
      "",
      "        fn lower_bound_by_key<'a, K, F>(&'a self, k: &K, f: F) -> usize",
      "        where",
      "            F: FnMut(&'a Self::Item) -> K,",
      "            K: Ord;",
      "",
      "        fn upper_bound(&self, x: &Self::Item) -> usize",
      "        where",
      "            Self::Item: Ord;",
      "",
      "        fn upper_bound_by<'a, F>(&'a self, f: F) -> usize",
      "        where",
      "            F: FnMut(&'a Self::Item) -> Ordering;",
      "",
      "        fn upper_bound_by_key<'a, K, F>(&'a self, k: &K, f: F) -> usize",
      "        where",
      "            F: FnMut(&'a Self::Item) -> K,",
      "            K: Ord;",
      "",
      "        fn equal_range(&self, x: &Self::Item) -> core::ops::Range<usize>",
      "        where",
      "            Self::Item: Ord;",
      "",
      "        fn equal_range_by<'a, F>(&'a self, f: F) -> core::ops::Range<usize>",
      "        where",
      "            F: FnMut(&'a Self::Item) -> Ordering;",
      "",
      "        fn equal_range_by_key<'a, K, F>(&'a self, k: &K, f: F) -> core::ops::Range<usize>",
      "        where",
      "            F: FnMut(&'a Self::Item) -> K,",
      "            K: Ord;",
      "",
      "        fn next_permutation(&mut self) -> bool",
      "        where",
      "            Self::Item: Ord;",
      "",
      "        fn prev_permutation(&mut self) -> bool",
      "        where",
      "            Self::Item: Ord;",
      "",
      "        fn apply_permutation(&mut self, permutation: &mut [isize]);",
      "",
      "        fn apply_inverse_permutation(&mut self, permutation: &mut [isize]);",
      "    }",
      "",
      "    impl<T> Ext for [T] {",
      "        type Item = T;",
      "",
      "        fn lower_bound(&self, x: &Self::Item) -> usize",
      "        where",
      "            T: Ord,",
      "        {",
      "            self.lower_bound_by(|y| y.cmp(x))",
      "        }",
      "        fn lower_bound_by<'a, F>(&'a self, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&'a Self::Item) -> Ordering,",
      "        {",
      "            let s = self;",
      "            let mut size = s.len();",
      "            if size == 0 {",
      "                return 0;",
      "            }",
      "            let mut base = 0usize;",
      "            while size > 1 {",
      "                let half = size / 2;",
      "                let mid = base + half;",
      "                let cmp = f(unsafe { s.get_unchecked(mid) });",
      "                base = if cmp == Less { mid } else { base };",
      "                size -= half;",
      "            }",
      "            let cmp = f(unsafe { s.get_unchecked(base) });",
      "            base + (cmp == Less) as usize",
      "        }",
      "        fn lower_bound_by_key<'a, K, F>(&'a self, k: &K, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&'a Self::Item) -> K,",
      "            K: Ord,",
      "        {",
      "            self.lower_bound_by(|e| f(e).cmp(k))",
      "        }",
      "",
      "        fn upper_bound(&self, x: &Self::Item) -> usize",
      "        where",
      "            T: Ord,",
      "        {",
      "            self.upper_bound_by(|y| y.cmp(x))",
      "        }",
      "",
      "        fn upper_bound_by<'a, F>(&'a self, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&'a Self::Item) -> Ordering,",
      "        {",
      "            let s = self;",
      "            let mut size = s.len();",
      "            if size == 0 {",
      "                return 0;",
      "            }",
      "            let mut base = 0usize;",
      "            while size > 1 {",
      "                let half = size / 2;",
      "                let mid = base + half;",
      "                let cmp = f(unsafe { s.get_unchecked(mid) });",
      "                base = if cmp == Greater { base } else { mid };",
      "                size -= half;",
      "            }",
      "            let cmp = f(unsafe { s.get_unchecked(base) });",
      "            base + (cmp != Greater) as usize",
      "        }",
      "        fn upper_bound_by_key<'a, K, F>(&'a self, k: &K, mut f: F) -> usize",
      "        where",
      "            F: FnMut(&'a Self::Item) -> K,",
      "            K: Ord,",
      "        {",
      "            self.upper_bound_by(|e| f(e).cmp(k))",
      "        }",
      "",
      "        fn equal_range(&self, x: &Self::Item) -> core::ops::Range<usize>",
      "        where",
      "            T: Ord,",
      "        {",
      "            self.equal_range_by(|y| y.cmp(x))",
      "        }",
      "        fn equal_range_by<'a, F>(&'a self, mut f: F) -> core::ops::Range<usize>",
      "        where",
      "            F: FnMut(&'a Self::Item) -> Ordering,",
      "        {",
      "            let s = self;",
      "            let mut size = s.len();",
      "            if size == 0 {",
      "                return 0..0;",
      "            }",
      "            let mut base = (0usize, 0usize);",
      "            while size > 1 {",
      "                let half = size / 2;",
      "                let mid = (base.0 + half, base.1 + half);",
      "                let cmp = (",
      "                    f(unsafe { s.get_unchecked(mid.0) }),",
      "                    f(unsafe { s.get_unchecked(mid.1) }),",
      "                );",
      "                base = (",
      "                    if cmp.0 == Less { mid.0 } else { base.0 },",
      "                    if cmp.1 == Greater { base.1 } else { mid.1 },",
      "                );",
      "                size -= half;",
      "            }",
      "            let cmp = (",
      "                f(unsafe { s.get_unchecked(base.0) }),",
      "                f(unsafe { s.get_unchecked(base.1) }),",
      "            );",
      "            base.0 + (cmp.0 == Less) as usize..base.1 + (cmp.1 != Greater) as usize",
      "        }",
      "",
      "        fn equal_range_by_key<'a, K, F>(&'a self, k: &K, mut f: F) -> core::ops::Range<usize>",
      "        where",
      "            F: FnMut(&'a Self::Item) -> K,",
      "            K: Ord,",
      "        {",
      "            self.equal_range_by(|e| f(e).cmp(k))",
      "        }",
      "",
      "        fn next_permutation(&mut self) -> bool",
      "        where",
      "            Self::Item: Ord,",
      "        {",
      "            // Adapted from http://en.cppreference.com/w/cpp/algorithm/next_permutation.",
      "            if self.len() <= 1 {",
      "                return false;",
      "            }",
      "            let last = self.len() - 1;",
      "            let mut a = last;",
      "            loop {",
      "                let mut b = a;",
      "                a -= 1;",
      "                if self[a] < self[b] {",
      "                    b = last;",
      "                    while self[a] >= self[b] {",
      "                        b -= 1;",
      "                    }",
      "                    self.swap(a, b);",
      "                    self[a + 1..].reverse();",
      "                    return true;",
      "                }",
      "                if a == 0 {",
      "                    self.reverse();",
      "                    return false;",
      "                }",
      "            }",
      "        }",
      "",
      "        fn prev_permutation(&mut self) -> bool",
      "        where",
      "            Self::Item: Ord,",
      "        {",
      "            // Adapted from http://en.cppreference.com/w/cpp/algorithm/prev_permutation.",
      "            if self.len() <= 1 {",
      "                return false;",
      "            }",
      "            let last = self.len() - 1;",
      "            let mut a = last;",
      "            loop {",
      "                let mut b = a;",
      "                a -= 1;",
      "                if self[b] < self[a] {",
      "                    b = last;",
      "                    while self[b] >= self[a] {",
      "                        b -= 1;",
      "                    }",
      "                    self.swap(a, b);",
      "                    self[a + 1..].reverse();",
      "                    return true;",
      "                }",
      "                if a == 0 {",
      "                    self.reverse();",
      "                    return false;",
      "                }",
      "            }",
      "        }",
      "",
      "        fn apply_permutation(&mut self, perm: &mut [isize]) {",
      "            assert_eq!(self.len(), perm.len());",
      "            assert!(self.len() < isize::max_value() as usize);",
      "            for i in 0..self.len() as isize {",
      "                let mut c = perm[i as usize];",
      "                if c < 0 {",
      "                    perm[i as usize] = !c;",
      "                } else if i != c {",
      "                    loop {",
      "                        let n = perm[c as usize];",
      "                        self.swap(c as usize, n as usize);",
      "                        perm[c as usize] = !n;",
      "                        c = n;",
      "                        if i == c {",
      "                            break;",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "",
      "        fn apply_inverse_permutation(&mut self, perm: &mut [isize]) {",
      "            assert_eq!(self.len(), perm.len());",
      "            assert!(self.len() < isize::max_value() as usize);",
      "            for i in 0..self.len() as isize {",
      "                let mut c = perm[i as usize];",
      "                if c < 0 {",
      "                    perm[i as usize] = !c;",
      "                } else if i != c {",
      "                    loop {",
      "                        self.swap(c as usize, i as usize);",
      "                        let n = perm[c as usize];",
      "                        perm[c as usize] = !n;",
      "                        c = n;",
      "                        if i == c {",
      "                            break;",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "",
      "    pub trait Ext2 {",
      "        fn invert_permutation(&mut self);",
      "    }",
      "",
      "    impl Ext2 for [isize] {",
      "        fn invert_permutation(&mut self) {",
      "            assert!(self.len() < isize::max_value() as usize);",
      "            for i in 0..self.len() as isize {",
      "                let mut c = self[i as usize];",
      "                if c < 0 {",
      "                    self[i as usize] = !c;",
      "                } else if i != c {",
      "                    let mut n = i;",
      "                    loop {",
      "                        let t = self[c as usize];",
      "                        self[c as usize] = !n;",
      "                        n = c;",
      "                        c = t;",
      "                        if c == i {",
      "                            self[i as usize] = n;",
      "                            break;",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "_transpose": {
    "prefix": "_transpose",
    "body": [
      "fn transpose<T: Clone + Copy + Default>(matrix: Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    if matrix.is_empty() {",
      "        return Vec::new();",
      "    }",
      "",
      "    let rows = matrix.len();",
      "    let cols = matrix[0].len();",
      "",
      "    let mut transposed = vec![vec![T::default(); rows]; cols];",
      "",
      "    for i in 0..rows {",
      "        for j in 0..cols {",
      "            transposed[j][i] = matrix[i][j];",
      "        }",
      "    }",
      "",
      "    transposed",
      "}"
    ],
    "description": "Function to transpose a matrix"
  },
  "_trie": {
    "prefix": "_trie",
    "body": [
      "#[derive(Debug)]",
      "pub struct Node {",
      "    count: usize,",
      "    children: [Option<Box<Node>>; 26],",
      "    is_end: bool,",
      "}",
      "",
      "impl Node {",
      "    pub fn new() -> Self {",
      "        Self {",
      "            count: 0,",
      "            children: Default::default(),",
      "            is_end: false,",
      "        }",
      "    }",
      "}",
      "",
      "#[derive(Debug)]",
      "pub struct Trie {",
      "    root: Node,",
      "}",
      "",
      "impl Trie {",
      "    pub fn new() -> Self {",
      "        Self { root: Node::new() }",
      "    }",
      "",
      "    pub fn insert(&mut self, s: &str) {",
      "        let mut node = &mut self.root;",
      "        for c in s.chars() {",
      "            let idx = c as usize - 'a' as usize;",
      "            if node.children[idx].is_none() {",
      "                node.children[idx] = Some(Box::new(Node::new()));",
      "            }",
      "            node = node.children[idx].as_deref_mut().unwrap();",
      "            node.count += 1;",
      "        }",
      "        node.is_end = true;",
      "    }",
      "",
      "    pub fn find(&self, s: &str) -> usize {",
      "        let mut node = &self.root;",
      "        for c in s.chars() {",
      "            let idx = c as usize - 'a' as usize;",
      "            if node.children[idx].is_none() {",
      "                return 0;",
      "            }",
      "            node = node.children[idx].as_deref().unwrap();",
      "        }",
      "        node.count",
      "    }",
      "",
      "    pub fn debug(&self, s: &str) {",
      "        let mut node = &self.root;",
      "        for c in s.chars() {",
      "            let idx = c as usize - 'a' as usize;",
      "            println!(\"{:?}\", node.children[idx]);",
      "            if node.children[idx].is_none() {",
      "                return;",
      "            }",
      "            node = node.children[idx].as_deref().unwrap();",
      "        }",
      "    }",
      "",
      "    pub fn contains(&self, s: &str) -> bool {",
      "        let mut node = &self.root;",
      "        for c in s.chars() {",
      "            let idx = c as usize - 'a' as usize;",
      "            match &node.children[idx] {",
      "                Some(child) => node = child.as_ref(),",
      "                None => return false,",
      "            }",
      "        }",
      "        node.is_end",
      "    }",
      "",
      "    pub fn substr_count(&self, s: &str) -> usize {",
      "        let mut node = &self.root;",
      "        let mut res = 0;",
      "        for c in s.chars() {",
      "            let idx = c as usize - 'a' as usize;",
      "            if node.children[idx].is_none() {",
      "                return res;",
      "            }",
      "            node = node.children[idx].as_deref().unwrap();",
      "            res += node.count;",
      "        }",
      "        res",
      "    }",
      "",
      "    pub fn delete(&mut self, s: &str) -> bool {",
      "        let mut node = &mut self.root;",
      "        for c in s.chars() {",
      "            let idx = (c as u8 - b'a') as usize;",
      "            if node.children[idx].as_ref().unwrap().count == 1 {",
      "                node.children[idx] = None;",
      "                return true;",
      "            }",
      "            let child = node.children[idx].as_deref_mut().unwrap();",
      "            child.count -= 1;",
      "            node = child;",
      "        }",
      "        node.is_end = false;",
      "        true",
      "    }",
      "}"
    ],
    "description": "A Trie (prefix tree) with insert, find, and substring count methods"
  },
  "_undo_unionfind": {
    "prefix": "_undo_unionfind",
    "body": [
      "#[derive(Clone, Debug)]",
      "pub struct RollbackUnionFind {",
      "    data: Vec<isize>,",
      "    history: Vec<(usize, isize)>,",
      "    inner_snap: usize,",
      "}",
      "",
      "impl RollbackUnionFind {",
      "    pub fn new(sz: usize) -> Self {",
      "        Self {",
      "            data: vec![-1; sz as usize],",
      "            history: Vec::new(),",
      "            inner_snap: 0,",
      "        }",
      "    }",
      "",
      "    pub fn merge(&mut self, x: usize, y: usize) -> bool {",
      "        let mut x = self.leader(x);",
      "        let mut y = self.leader(y);",
      "",
      "        self.history.push((x, self.data[x]));",
      "        self.history.push((y, self.data[y]));",
      "",
      "        if x == y {",
      "            return false;",
      "        }",
      "        if self.data[x] > self.data[y] {",
      "            swap(&mut x, &mut y);",
      "        }",
      "        self.data[x] += self.data[y];",
      "        self.data[y] = x as isize;",
      "        true",
      "    }",
      "",
      "    pub fn leader(&self, k: usize) -> usize {",
      "        if self.data[k] < 0 {",
      "            k",
      "        } else {",
      "            self.leader(self.data[k] as usize)",
      "        }",
      "    }",
      "",
      "    pub fn same(&self, x: usize, y: usize) -> bool {",
      "        self.leader(x) == self.leader(y)",
      "    }",
      "",
      "    pub fn size(&self, k: usize) -> usize {",
      "        (-self.data[self.leader(k)]) as usize",
      "    }",
      "",
      "    pub fn undo(&mut self) {",
      "        let (i1, v1) = self.history.pop().expect(\"No history to undo\");",
      "        self.data[i1] = v1;",
      "        let (i0, v0) = self.history.pop().expect(\"No history to undo\");",
      "        self.data[i0] = v0;",
      "    }",
      "",
      "    pub fn snapshot(&mut self) {",
      "        self.inner_snap = self.history.len() >> 1;",
      "    }",
      "",
      "    pub fn get_state(&self) -> usize {",
      "        self.history.len() >> 1",
      "    }",
      "",
      "    // state回 mergeした状態に戻す",
      "    pub fn rollback(&mut self, state: Option<usize>) {",
      "        let target_pairs = state.unwrap_or(self.inner_snap);",
      "        let target_entries = target_pairs << 1;",
      "        assert!(",
      "            target_entries <= self.history.len(),",
      "            \"rollback target is ahead of current history\"",
      "        );",
      "        while self.history.len() > target_entries {",
      "            self.undo();",
      "        }",
      "    }",
      "}",
      ""
    ]
  },
  "_wakugai_hw": {
    "prefix": "_wakugai_hw",
    "body": [
      "let ni = i as isize + di;",
      "let nj = j as isize + dj;",
      "if ni < 0 || ni >= h as isize || nj < 0 || nj >= w as isize {",
      "    continue;",
      "}",
      "let ni = ni as usize;",
      "let nj = nj as usize;"
    ],
    "description": "wakugai hantei"
  },
  "_yakusuu": {
    "prefix": "_yakusuu",
    "body": [
      "fn yakusuu(n: usize) -> HashSet<usize> {",
      "    let mut ret = HashSet::new();",
      "    let mut now = 1usize;",
      "    for i in 1..=n {",
      "        if now.pow(2) > n {",
      "            break;",
      "        }",
      "        if n % now == 0 {",
      "            ret.insert(now);",
      "            ret.insert(n / now);",
      "        }",
      "        now += 1;",
      "    }",
      "    ret",
      "}"
    ],
    "description": "Function to calculate divisors"
  },
  "_zaatsu": {
    "prefix": "_zaatsu",
    "body": [
      "pub use coordinate_compression::*;",
      "pub mod coordinate_compression {",
      "    use std::{collections::HashMap, hash::Hash};",
      "",
      "    pub struct CoordinateCompression<T: Ord + Copy + Hash + Eq> {",
      "        max_id: usize,",
      "        id_map: HashMap<T, usize>",
      "    }",
      "    impl<T: Ord + Copy + Hash + Eq> CoordinateCompression<T> {",
      "        pub fn new(ary: &[T]) -> Self {",
      "            let mut id = 0;",
      "            let mut id_map = HashMap::new();",
      "            let mut ary = ary.to_owned();",
      "            ary.sort();",
      "            ary.dedup();",
      "            for &num in ary.iter() {",
      "                id_map.insert(num, id);",
      "                id += 1usize;",
      "            }",
      "            Self {",
      "                max_id: id,",
      "                id_map",
      "            }",
      "        }",
      "",
      "        pub fn get(&self, num: &T) -> usize {",
      "            self.id_map[num]",
      "        }",
      "",
      "        pub fn len(&self) -> usize {",
      "            self.max_id",
      "        }",
      "    }",
      "}",
      ""
    ]
  },
  "eratosthenes_struct": {
    "prefix": "_eratosthenes",
    "body": [
      "use erathosthenes::*;",
      "pub mod erathosthenes {",
      "    use num::{FromPrimitive, ToPrimitive};",
      "",
      "    pub struct Eratosthenes<T> {",
      "        pub sosus: Vec<T>,",
      "        pub first_soinsu: Vec<T>,",
      "    }",
      "",
      "    impl<T> Eratosthenes<T>",
      "    where",
      "        T: ToPrimitive + FromPrimitive + Copy + Clone,",
      "    {",
      "        pub fn new(max_size: T) -> Self {",
      "            let leng = max_size.to_usize().unwrap();",
      "            let mut furui = vec![true; leng + 1];",
      "            let mut first = vec![T::from_i8(1).unwrap(); leng + 1];",
      "            let mut primes = vec![];",
      "            furui[0] = false;",
      "            furui[1] = false;",
      "",
      "            for i in 2..=leng {",
      "                if !furui[i] {",
      "                    continue;",
      "                }",
      "                let ans = T::from_usize(i).unwrap();",
      "                primes.push(ans);",
      "                first[i] = ans;",
      "                let mut now = i * i; ",
      "                if now > leng {",
      "                    continue;",
      "                }",
      "                loop {",
      "                    if now > leng {",
      "                        break;",
      "                    }",
      "                    furui[now] = false;",
      "                    first[now] = ans;",
      "                    now += i;",
      "                }",
      "            }",
      "            Self {",
      "                sosus: primes,",
      "                first_soinsu: first,",
      "            }",
      "        }",
      "",
      "        pub fn factorization(&self, num: T) -> Vec<T> {",
      "            let mut ans = vec![];",
      "            let mut now = num.to_usize().unwrap();",
      "            if now >= self.first_soinsu.len() {",
      "                panic!(\"高望みするな\")",
      "            }",
      "            loop {",
      "                let ne = self.first_soinsu[now];",
      "                ans.push(ne);",
      "                now /= ne.to_usize().unwrap();",
      "                if now == 1 {",
      "                    break;",
      "                }",
      "            }",
      "            ans",
      "        }",
      "    }",
      "}",
      ""
    ],
    "description": "Eratosthenes sieve with prime-factorization helper (Rust)"
  },
  "init": {
    "prefix": "_init",
    "body": [
      "#[rustfmt::skip]",
      "pub mod lib {pub use ac_library::*;pub use itertools::{join, Combinations, Itertools, MultiProduct, Permutations};pub use proconio::{input,marker::{Chars, Usize1}};pub use std::{cmp::*, collections::*, mem::swap};pub use regex::Regex;pub use superslice::Ext;pub use num_traits::{One, ToPrimitive, FromPrimitive, PrimInt};#[macro_export]macro_rules! degg {(\\$(\\$val:expr),+ \\$(,)?) => {println!(\"[{}:{}] {}\",file!(),line!(),{let mut parts = Vec::new();\\$(parts.push(format!(\"{} = {:?}\", stringify!(\\$val), &\\$val));)+parts.join(\", \")})}}}",
      "",
      "use lib::*;",
      "",
      "fn main() {",
      "    input! {",
      "",
      "    }",
      "}"
    ]
  },
  "zero_format": {
    "prefix": "_zero_format",
    "body": [
      "#[ext(StUtil)]",
      "impl <T> T",
      "where ",
      "    T: PrimInt + Display",
      "{",
      "    fn zero_format(&self, width: usize) -> String {",
      "        format!(\"{:0width\\$}\", self, width = width)",
      "    }",
      "}"
    ],
    "description": "Adds a zero-padded formatting helper to any integer type implementing PrimInt + Display"
  }
}