{
  "_transpose": {
    "prefix": "_transpose",
    "body": [
      "fn transpose<T: Clone + Copy + Default>(matrix: Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    if matrix.is_empty() {",
      "        return Vec::new();",
      "    }",
      "",
      "    let rows = matrix.len();",
      "    let cols = matrix[0].len();",
      "",
      "    let mut transposed = vec![vec![T::default(); rows]; cols];",
      "",
      "    for i in 0..rows {",
      "        for j in 0..cols {",
      "            transposed[j][i] = matrix[i][j];",
      "        }",
      "    }",
      "",
      "    transposed",
      "}"
    ],
    "description": "Function to transpose a matrix"
  },
  "_rotate_90_degrees": {
    "prefix": "_rotate_90_degrees",
    "body": [
      "fn rotate_90_degrees<T: Clone>(matrix: Vec<Vec<T>>) -> Vec<Vec<T>> {",
      "    let rows = matrix.len();",
      "    let cols = matrix[0].len();",
      "    let mut rotated = vec![vec![matrix[0][0].clone(); rows]; cols];",
      "",
      "    for i in 0..rows {",
      "        for j in 0..cols {",
      "            rotated[j][rows - i - 1] = matrix[i][j].clone();",
      "        }",
      "    }",
      "",
      "    rotated",
      "}"
    ],
    "description": "Function to rotate a matrix 90 degrees clockwise"
  },
  "_chmax": {
    "prefix": "_chmax",
    "body": [
      "macro_rules! chmax {",
      "    (\\$val: expr, \\$new: expr) => {",
      "        if \\$val < \\$new {",
      "            \\$val = \\$new;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    };",
      "}"
    ],
    "description": "chmax"
  },
  "_chmin": {
    "prefix": "_chmin",
    "body": [
      "macro_rules! chmin {",
      "    (\\$val: expr, \\$new: expr) => {",
      "        if \\$val > \\$new {",
      "            \\$val = \\$new;",
      "            true",
      "        } else {",
      "            false",
      "        }",
      "    };",
      "}"
    ],
    "description": "chmin"
  },
  "_hutarigumi_dfs": {
    "prefix": "_hutarigumi_dfs",
    "body": [
      "fn hutarigumi_dfs(set: &mut HashSet<usize>, ans: &mut Vec<Vec<(usize, usize)>>, now: &mut Vec<(usize, usize)>) {",
      "    let set_c = set.clone().into_iter().collect_vec();",
      "    let first = set_c[0];",
      "    set.remove(&first);",
      "    for &num in set_c.iter() {",
      "        set.remove(&num);",
      "        now.push((first, num));",
      "        if set.len() == 0 {",
      "            ans.push(now.to_vec());",
      "            now.pop();",
      "            set.insert(first);",
      "            set.insert(num);",
      "            return;",
      "        }",
      "        dfs(set, ans, now);",
      "        set.insert(num);",
      "        now.pop();",
      "    }",
      "    set.insert(first);",
      "}"
    ],
    "description": "DFS function for pairing elements in a set"
  },
  "_gcd": {
    "prefix": "_gcd",
    "body": [
      "fn gcd(mut a: usize, mut b: usize) -> usize {",
      "    while b != 0 {",
      "        (a, b) = (b, a % b);",
      "    }",
      "    a",
      "}"
    ],
    "description": "Function to compute the greatest common divisor (GCD)"
  },
  "_lcm": {
    "prefix": "_lcm",
    "body": [
      "fn lcm(a: usize, b: usize) -> usize {",
      "    (a * b) / gcd(a, b)",
      "}"
    ],
    "description": "Function to compute the least common multiple (LCM)"
  },
  "_extgcd": {
    "prefix": "_extgcd",
    "body": [
      "fn extgcd(a: isize, b: isize, i: &mut isize, j: &mut isize) -> isize {",
      "    if b == 0 {",
      "        *i = 1;",
      "        *j = 0;",
      "        return a;",
      "    }",
      "    let p = a / b;",
      "    let g = extgcd(b, a - b * p, j, i);",
      "    *j -= p * *i;",
      "    g",
      "}"
    ],
    "description": "Extended Euclidean Algorithm to find GCD and coefficients"
  },
  "_eratosthenes": {
    "prefix": "_eratosthenes",
    "body": [
      "fn eratosthenes(${1:max_number}: u128) -> (Vec<u128>, Vec<u128>) {",
      "    let mut sieve = vec![true; (${1} + 1) as usize];",
      "    sieve[0] = false;",
      "    sieve[1] = false;",
      "    // 最初の素因数",
      "    let mut soinsu = vec![1; (${1} + 1) as usize];",
      "",
      "    for i in 2..=( ${1} as usize ) {",
      "        if (i as u128) * (i as u128) > ${1} {",
      "            break;",
      "        }",
      "        if sieve[i] {",
      "            for j in (i * i..=(${1} as usize)).step_by(i) {",
      "                sieve[j] = false;",
      "                soinsu[j] = i as u128;",
      "            }",
      "        }",
      "    }",
      "",
      "    let ret1 = sieve.iter().enumerate().filter_map(|(i, &is_prime)| {",
      "        if is_prime {",
      "            Some(i as u128)",
      "        } else {",
      "            None",
      "        }",
      "    }).collect_vec();",
      "",
      "    (ret1, soinsu)",
      "}"
    ],
    "description": "Compute sieve of Eratosthenes up to ${1} and record smallest prime factor for each number"
  },
  "_eratosthenes2": {
    "prefix": "_eratosthenes2",
    "body": [
      "fn eratosthenes<$1>(max_number: $1) -> (Vec<$1>, Vec<$1>)",
      "where",
      "    $1: One + ToPrimitive + FromPrimitive + Copy,",
      "{",
      "    let max_usize = max_number",
      "        .to_usize()",
      "        .expect(\"max_number is too large for usize\");",
      "",
      "    let mut sieve = vec![true; max_usize + 1];",
      "    sieve[0] = false;",
      "    sieve[1] = false;",
      "    let mut spf = vec![$1::one(); max_usize + 1];",
      "",
      "    let mut primes = Vec::new();",
      "    for i in 2..=max_usize {",
      "        if sieve[i] {",
      "            let ti = $1::from_usize(i).unwrap();",
      "            primes.push(ti);",
      "            let ii = i * i;",
      "            if ii > max_usize { continue; }",
      "            for j in (ii..=max_usize).step_by(i) {",
      "                sieve[j] = false;",
      "                spf[j] = ti;",
      "            }",
      "        }",
      "    }",
      "",
      "    (primes, spf)",
      "}"
    ],
    "description": "Generic Eratosthenes sieve producing prime list and SPF table for any integer type T"
  },
  "_zero_format": {
    "prefix": "_zero_format",
    "body": [
      "fn zero_format() {",
      "    let fmt = format!(\"{:0>n\\$}\", i);",
      "}"
    ],
    "description": "Function to format number with leading zeros"
  },
  "_soinsu_factorization": {
    "prefix": "_soinsu_factorization",
    "body": [
      "fn factorization(mut x: i64) -> Vec<(i64, i64)> {",
      "    let mut resu = Vec::new();",
      "    for i in 2.. {",
      "        if i*i > x { break; }",
      "        if x % i != 0 { continue; }",
      "",
      "        let mut e = 0;",
      "        while x % i == 0 {",
      "            e += 1;",
      "            x /= i;",
      "        }",
      "",
      "        resu.push((i, e));",
      "    }",
      "",
      "    if x != 1 {",
      "        resu.push((x, 1));",
      "    }",
      "",
      "    resu",
      "}"
    ],
    "description": "Function to perform prime factorization"
  },
  "_sqrt_nibutan": {
    "prefix": "_sqrt_nibutan",
    "body": [
      "fn sqrt_i128(v: i128) -> i128 {",
      "    let mut ok = 0;",
      "    let mut ng = v;",
      "    while ng - ok > 1 {",
      "        let mid = (ok + ng) / 2;",
      "        if mid * mid <= v {",
      "            ok = mid;",
      "        } else {",
      "            ng = mid;",
      "        }",
      "    }",
      "    ok",
      "}"
    ],
    "description": "Function to compute the integer square root of an i128"
  },
  "_is_prime_miller": {
    "prefix": "_is_prime_miller",
    "body": [
      "fn is_prime_miller(n: u64) -> bool {",
      "    if n <= 1 {",
      "        return false;",
      "    } else if n <= 3 {",
      "        return true;",
      "    } else if n % 2 == 0 {",
      "        return false;",
      "    }",
      "    let pow = |r: u64, mut m: u64| -> u64 {",
      "        let mut t = 1u128;",
      "        let mut s = (r % n) as u128;",
      "        let n = n as u128;",
      "        while m > 0 {",
      "            if m & 1 == 1 {",
      "                t = t * s % n;",
      "            }",
      "            s = s * s % n;",
      "            m >>= 1;",
      "        }",
      "        t as u64",
      "    };",
      "    let mut d = n - 1;",
      "    let mut s = 0;",
      "    while d % 2 == 0 {",
      "        d /= 2;",
      "        s += 1;",
      "    }",
      "    const B: [u64; 7] = [2, 325, 9375, 28178, 450775, 9780504, 1795265022];",
      "    for &b in B.iter() {",
      "        let mut a = pow(b, d);",
      "        if a <= 1 {",
      "            continue;",
      "        }",
      "        let mut i = 0;",
      "        while i < s && a != n - 1 {",
      "            i += 1;",
      "            a = (a as u128 * a as u128 % n as u128) as u64;",
      "        }",
      "        if i >= s {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}"
    ],
    "description": "Miller-Rabin primality test"
  },
  "_sishagonyu_seisuu": {
    "prefix": "_sishagonyu_seisuu",
    "body": [
      "fn sishagonyu_seisuu(x: f64) -> f64 {",
      "    let tmp = 10f64.pow(3 as i32);",
      "    let ans = (x / tmp).round() * tmp;",
      "    ans",
      "}"
    ],
    "description": "Function for rounding to integer values"
  },
  "_sishagonyu_shousuu": {
    "prefix": "_sishagonyu_shousuu",
    "body": [
      "fn sishagonyu_shousuu(x: f64) -> f64 {",
      "    let tmp = 10f64.pow(3 as i32);",
      "    let ans = (x * tmp).round() / tmp;",
      "    ans",
      "}"
    ],
    "description": "Function for rounding to decimal values"
  },
  "_nck": {
    "prefix": "_nck",
    "body": [
      "fn nck(n: u128, k: u128) -> u128 {",
      "    if k > n {",
      "        return 0;",
      "    }",
      "",
      "    let k = if k > n - k { n - k } else { k };",
      "",
      "    let mut result = 1;",
      "    for i in 0..k {",
      "        result = result * (n - i) / (i + 1);",
      "    }",
      "",
      "    result",
      "}"
    ],
    "description": "Function to calculate binomial coefficient (n choose k)"
  },
  "_product_repeat": {
    "prefix": "_product_repeat",
    "body": [
      "pub trait ProductRepeat: Iterator + Clone",
      "where",
      "    Self::Item: Clone,",
      "{",
      "    fn product_repeat(self, repeat: usize) -> MultiProduct<Self> {",
      "        std::iter::repeat(self).take(repeat).multi_cartesian_product()",
      "    }",
      "}",
      "",
      "impl<T: Iterator + Clone> ProductRepeat for T where T::Item: Clone {}"
    ],
    "description": "Trait for repeating product cartesian"
  },
  "_isize_ceil": {
    "prefix": "_isize_ceil",
    "body": [
      "fn isize_ceil(a: isize, b: isize) -> isize {",
      "    if (a + b - 1 < 0) && (a + b - 1) % b != 0 {",
      "        return (a + b - 1)/ b - 1;",
      "    }",
      "    return (a + b - 1) / b;",
      "}"
    ],
    "description": "Function to calculate isize ceil"
  },
  "_isize_floor_div": {
    "prefix": "_isize_floor_div",
    "body": [
      "fn isize_floor_div(x: isize, m: isize) -> isize {",
      "    let r = (x % m + m) % m;",
      "    (x - r) / m",
      "}"
    ],
    "description": "Function to calculate isize floor division"
  },
  "_yakusuu": {
    "prefix": "_yakusuu",
    "body": [
      "fn yakusuu(n: usize) -> HashSet<usize> {",
      "    let mut ret = HashSet::new();",
      "    let mut now = 1usize;",
      "    for i in 1..=n {",
      "        if now.pow(2) > n {",
      "            break;",
      "        }",
      "        if n % now == 0 {",
      "            ret.insert(now);",
      "            ret.insert(n / now);",
      "        }",
      "        now += 1;",
      "    }",
      "    ret",
      "}"
    ],
    "description": "Function to calculate divisors"
  },
  "_Trie": {
    "prefix": "_Trie",
    "body": [
      "pub struct Node {",
      "    cnt: usize,",
      "    next: HashMap<char, Node>,",
      "}",
      "",
      "impl Node {",
      "    pub fn new() -> Self {",
      "        Self {",
      "            cnt: 0,",
      "            next: HashMap::new(),",
      "        }",
      "    }",
      "",
      "    pub fn contain(&self, key: char) -> bool {",
      "        self.next.contains_key(&key)",
      "    }",
      "}",
      "pub struct Trie {",
      "    root: Node,",
      "}",
      "",
      "impl Trie {",
      "    pub fn new() -> Self {",
      "        Self { root: Node::new() }",
      "    }",
      "",
      "    pub fn insert(&mut self, seq: &Vec<char>) {",
      "        let mut node = &mut self.root;",
      "        node.cnt += 1;",
      "        for &s in seq.iter() {",
      "            node = node.next.entry(s).or_insert_with(Node::new);",
      "            node.cnt += 1;",
      "        }",
      "        node = node.next.entry(0 as char).or_insert_with(Node::new);",
      "        node.cnt += 1;",
      "    }",
      "",
      "    pub fn length2(&self, seq: &Vec<char>, cnt_lb: usize) -> usize {",
      "        let mut ret = 0;",
      "        let mut node = &self.root;",
      "        for s in seq.iter() {",
      "            if let Some(next) = node.next.get(s) {",
      "                node = next;",
      "                if node.cnt >= cnt_lb {",
      "                    ret += 1;",
      "                } else {",
      "                    break;",
      "                }",
      "            } else {",
      "                break;",
      "            }",
      "        }",
      "        ret",
      "    }",
      "",
      "    pub fn search(&self, seq: &Vec<char>) -> bool {",
      "        let mut node = &self.root;",
      "        for &s in seq.iter() {",
      "            if let Some(next) = node.next.get(&s) {",
      "                node = next;",
      "            } else {",
      "                return false;",
      "            }",
      "        }",
      "        node.next.contains_key(&(0 as char))",
      "    }",
      "",
      "    pub fn starts_with(&self, prefix: &Vec<char>) -> bool {",
      "        let mut node = &self.root;",
      "        for &s in prefix.iter() {",
      "            if let Some(next) = node.next.get(&s) {",
      "                node = next;",
      "            } else {",
      "                return false;",
      "            }",
      "        }",
      "        true",
      "    }",
      "}"
    ],
    "description": "Trie struct with insert, search, and starts_with methods"
  },
  "_hash_value_program": {
    "prefix": "_hash_value_program",
    "body": [
      "const MOD:isize = 214783647;",
      "fn hash_value(l:usize, r:usize, h:&Vec<isize>, p:&Vec<isize>) -> Option<isize> {",
      "    if r + 1 < l {",
      "        return None;",
      "    }",
      "    let mut v = h[r + 1] - (h[l] * p[r - l + 1] % MOD);",
      "    if v < 0 {",
      "        v += MOD;",
      "    };",
      "    Some(v)",
      "}",
      "",
      "fn main() {",
      "    input! {",
      "        (n, q): (usize, usize),",
      "        s: Chars,",
      "    }",
      "    let mut p = vec![];",
      "    p.push(1);",
      "    for i in 1..=n {",
      "        p.push(100 * p[i - 1] % MOD);",
      "    }",
      "    let mut t = vec![];",
      "    for c in s {",
      "        t.push(c as isize - 'a' as isize + 1);",
      "    }",
      "    let mut h = vec![];",
      "    h.push(0);",
      "    for i in 1..=n {",
      "        h.push((100 * h[i - 1] + t[i - 1]) % MOD);",
      "    }",
      "    for _i in 0..q {",
      "        input! {(a, b, c, d): (Usize1, Usize1, Usize1, Usize1)}",
      "        let hash1 = hash_value(a, b, &h, &p);",
      "        let hash2 = hash_value(c, d, &h, &p);",
      "        let ans = if hash1 == hash2 { \"Yes\" } else { \"No\" };",
      "        println!(\"{}\", ans);",
      "    }",
      "}"
    ],
    "description": "String hash comparison using rolling hash"
  },
  "_didj": {
    "prefix": "_didj",
    "body": [
      "let didj = vec![(1, 0), (-1, 0), (0, 1), (0, -1)];"
    ],
    "description": "4 directions didj"
  },
  "_didj8": {
    "prefix": "_didj8",
    "body": [
      "let didj = vec![(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)];"
    ],
    "description": "8 directions didj"
  },
  "_wakugai_hw": {
    "prefix": "_wakugai_hw",
    "body": [
      "let ni = i as isize + di;",
      "let nj = j as isize + dj;",
      "if ni < 0 || ni >= h as isize || nj < 0 || nj >= w as isize {",
      "    continue;",
      "}",
      "let ni = ni as usize;",
      "let nj = nj as usize;"
    ],
    "description": "wakugai hantei"
  },
  "_ceil": {
    "prefix": "_ceil",
    "body": [
      "let ceil = |a: usize, b: usize| {",
      "    (a + b - 1) / b",
      "};"
    ],
    "description": "Ceil calculation"
  },
  "_nc2": {
    "prefix": "_nc2",
    "body": [
      "let nc2 = |n: usize| {",
      "    if n <= 1 {",
      "        return 0;",
      "    }",
      "    n * (n - 1) / 2",
      "};"
    ],
    "description": "nc2 calculation"
  },
  "_nc3": {
    "prefix": "_nc3",
    "body": [
      "let nc3 = |n: usize| {",
      "    if n <= 2 {",
      "        return 0;",
      "    }",
      "    n * (n - 1) * (n - 2) / 6",
      "};"
    ],
    "description": "nc3 calculation"
  },
  "_modpow": {
    "prefix": "_modpow",
    "body": [
      "fn mod_pow(mut x: usize, mut n: usize, m: usize) -> usize {",
      "    x %= m;",
      "    let mut ans = 1;",
      "    while n != 0 {",
      "        if n.is_odd() {",
      "            ans = ans * x % m;",
      "        }",
      "        x = x * x % m;",
      "        n >>= 1;",
      "    }",
      "    ans",
      "}"
    ],
    "description": "Calculates (x^n) % m efficiently using binary exponentiation."
  },
  "_mod_nck_9982": {
    "prefix": "_mod_nck_9982",
    "body": [
      "type Mint = ModInt998244353;",
      "fn factorial(nmax: usize) -> (Vec<Mint>, Vec<Mint>) {",
      "    let mut fact = vec![Mint::new(1); nmax + 1];",
      "    let mut ifact = vec![Mint::new(0); nmax + 1];",
      "    for i in 1..=nmax {",
      "        fact[i] = fact[i-1] * i;",
      "    }",
      "    ifact[nmax] = fact[nmax].inv();",
      "    for i in (1..=nmax).rev() {",
      "        ifact[i-1] = ifact[i] * i;",
      "    }",
      "    return (fact, ifact);",
      "}",
      "",
      "fn comb(n: usize, r: usize, fact: &Vec<Mint>, ifact: &Vec<Mint>) -> Mint {",
      "    if n < r {",
      "        return Mint::new(0);",
      "    }",
      "    return fact[n] * ifact[r] * ifact[n-r];",
      "}"
    ],
    "description": "Generates factorial and comb functions using ModInt998244353 for modular arithmetic."
  },
  "_2vec": {
    "prefix": "_2vec",
    "body": [
      "vec![vec![]]"
    ],
    "description": "2vec"
  },
  "_cycle": {
    "prefix": "_cycle",
    "body": [
      "fn dfs(now: usize, pre: &mut Vec<Option<usize>>, g: &Vec<Vec<usize>>, ans: &mut Vec<usize>, p: usize) -> (usize, usize) {",
      "    for &v2 in g[now].iter() {",
      "        if v2 == p {",
      "            continue;",
      "        }",
      "        if !pre[v2].is_none() {",
      "            ans.push(now);",
      "            return (1, v2);",
      "        }",
      "        pre[v2] = Some(now);",
      "        let jud = dfs(v2, pre, g, ans, now);",
      "        if jud.0 == 1 {",
      "            ans.push(now);",
      "            if jud.1 == now {",
      "                return (0, usize::MAX);",
      "            } else {",
      "                return jud;",
      "            }",
      "        }",
      "    }",
      "    return (0, usize::MAX);",
      "}"
    ],
    "description": "DFS function for cycle detection in a graph"
  },
  "_frac": {
    "prefix": "_frac",
    "body": [
      "use std::ops::Sub;",
      "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]",
      "pub struct Frac(i128, i128); // Normalized (numerator / denominator)",
      "",
      "impl Frac {",
      "    pub fn new(a: i128, b: i128) -> Self {",
      "        Frac(a, b).normalize()",
      "    }",
      "    fn normalize(&mut self) -> Self {",
      "        let g = Self::gcd(self.0.abs(), self.1.abs());",
      "        self.0 /= g;",
      "        self.1 /= g;",
      "        if self.1 < 0 {",
      "            self.0 *= -1;",
      "            self.1 *= -1;",
      "        }",
      "        *self",
      "    }",
      "    pub fn from(x: i128) -> Self {",
      "        Frac(x, 1)",
      "    }",
      "    pub fn inv(&self) -> Self {",
      "        if self.0 > 0 {",
      "            Frac(self.1, self.0)",
      "        } else if self.0 < 0 {",
      "            Frac(-self.1, -self.0)",
      "        } else {",
      "            Frac(1, 0) //Infinity",
      "        }",
      "    }",
      "    fn gcd(a: i128, b: i128) -> i128 {",
      "        if b == 0 {",
      "            a",
      "        } else {",
      "            Self::gcd(b, a % b)",
      "        }",
      "    }",
      "    fn lcm(a: i128, b: i128) -> i128 {",
      "        a / Self::gcd(a, b) * b",
      "    }",
      "    pub fn is_inf(&self) -> bool {",
      "        *self == Self::new(1, 0) || *self == Self::new(-1, 0)",
      "    }",
      "}",
      "",
      "impl std::ops::Add<i128> for Frac {",
      "    type Output = Self;",
      "    fn add(self, z: i128) -> Self {",
      "        Self::new(self.0 + self.1 * z, self.1)",
      "    }",
      "}",
      "impl std::ops::Add for Frac {",
      "    type Output = Self;",
      "    fn add(self, other: Self) -> Self {",
      "        let num = Self::lcm(self.1, other.1);",
      "        let numerator = self.0 * num / self.1 + other.0 * num / other.1;",
      "        Self::new(numerator, num)",
      "    }",
      "}",
      "impl std::ops::AddAssign<i128> for Frac {",
      "    fn add_assign(&mut self, z: i128) {",
      "        self.0 += self.1 * z;",
      "        self.normalize();",
      "    }",
      "}",
      "impl std::ops::Sub<i128> for Frac {",
      "    type Output = Self;",
      "    fn sub(self, z: i128) -> Self {",
      "        self + (-z)",
      "    }",
      "}",
      "impl std::ops::Sub for Frac {",
      "    type Output = Self;",
      "    fn sub(self, other: Self) -> Self {",
      "        let num = Self::lcm(self.1, other.1);",
      "        let numerator = self.0 * num / self.1 - other.0 * num / other.1;",
      "        Self::new(numerator, num)",
      "    }",
      "}",
      "impl std::ops::SubAssign<i128> for Frac {",
      "    fn sub_assign(&mut self, z: i128) {",
      "        *self += -z;",
      "    }",
      "}",
      "impl std::ops::Mul<i128> for Frac {",
      "    type Output = Self;",
      "    fn mul(self, z: i128) -> Self {",
      "        Self::new(self.0 * z, self.1)",
      "    }",
      "}",
      "impl std::ops::Mul for Frac {",
      "    type Output = Self;",
      "    fn mul(self, other: Self) -> Self {",
      "        let numerator = self.0 * other.0;",
      "        let denominator = self.1 * other.1;",
      "        Self::new(numerator, denominator)",
      "    }",
      "}",
      "impl std::ops::MulAssign<i128> for Frac {",
      "    fn mul_assign(&mut self, z: i128) {",
      "        self.0 *= z;",
      "        self.normalize();",
      "    }",
      "}",
      "impl std::ops::Div for Frac {",
      "    type Output = Self;",
      "    fn div(self, other: Self) -> Self {",
      "        Self::new(self.0 * other.1, self.1 * other.0)",
      "    }",
      "}",
      "impl std::ops::Div<i128> for Frac {",
      "    type Output = Self;",
      "    fn div(self, other: i128) -> Self {",
      "        Self::new(self.0, self.1 * other)",
      "    }",
      "}",
      "impl std::ops::DivAssign<i128> for Frac {",
      "    fn div_assign(&mut self, z: i128) {",
      "        self.1 *= z;",
      "        self.normalize();",
      "    }",
      "}",
      "impl PartialOrd for Frac {",
      "    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
      "        let left = self.0 * other.1;",
      "        let right = other.0 * self.1;",
      "        left.partial_cmp(&right)",
      "    }",
      "}",
      "impl Ord for Frac {",
      "    fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
      "        self.partial_cmp(&other).unwrap()",
      "    }",
      "}"
    ],
    "description": "Fraction struct with arithmetic and comparison operators implemented"
  },
  "_round": {
    "prefix": "_round",
    "body": [
      "fn round(x: usize, i: u32) -> usize {",
      "    let ip = 10usize.pow(i + 1);",
      "    let ii = 10usize.pow(i);",
      "    ((x + 5 * ii) / ip) * ip",
      "}"
    ],
    "description": "round"
  },
  "_proconio": {
    "prefix": "_proconio",
    "body": [
      "macro_rules! input {",
      "    (source = \\$s:expr, \\$(\\$r:tt)*) => {",
      "        let mut iter = \\$s.split_whitespace();",
      "        input_inner!{iter, \\$(\\$r)*}",
      "    };",
      "    (\\$(\\$r:tt)*) => {",
      "        let mut s = {",
      "            use std::io::Read;",
      "            let mut s = String::new();",
      "            std::io::stdin().read_to_string(&mut s).unwrap();",
      "            s",
      "        };",
      "        let mut iter = s.split_whitespace();",
      "        input_inner!{iter, \\$(\\$r)*}",
      "    };",
      "}",
      "",
      "macro_rules! input_inner {",
      "    (\\$iter:expr) => {};",
      "    (\\$iter:expr, ) => {};",
      "",
      "    (\\$iter:expr, \\$var:ident : \\$t:tt \\$(\\$r:tt)*) => {",
      "        let \\$var = read_value!(\\$iter, \\$t);",
      "        input_inner!{\\$iter \\$(\\$r)*}",
      "    };",
      "}",
      "",
      "macro_rules! read_value {",
      "    (\\$iter:expr, ( \\$(\\$t:tt),* )) => {",
      "        ( \\$(read_value!(\\$iter, \\$t)),* )",
      "    };",
      "",
      "    (\\$iter:expr, [ \\$t:tt ; \\$len:expr ]) => {",
      "        (0..\\$len).map(|_| read_value!(\\$iter, \\$t)).collect::<Vec<_>>()",
      "    };",
      "",
      "    (\\$iter:expr, chars) => {",
      "        read_value!(\\$iter, String).chars().collect::<Vec<char>>()",
      "    };",
      "",
      "    (\\$iter:expr, usize1) => {",
      "        read_value!(\\$iter, usize) - 1",
      "    };",
      "",
      "    (\\$iter:expr, \\$t:ty) => {",
      "        \\$iter.next().unwrap().parse::<\\$t>().expect(\"Parse error\")",
      "    };",
      "}"
    ],
    "description": "Proconio-like input macro for competitive programming in Rust."
  },
  "_matrix_kake": {
    "prefix": "_matrix_kake",
    "body": [
      "fn multiply_matrices<T: std::ops::Mul<Output = T> + std::iter::Sum + Copy + Default>(a: &Vec<Vec<T>>, b: &Vec<Vec<T>>) -> Option<Vec<Vec<T>>> {",
      "    if a[0].len() != b.len() {",
      "        return None;",
      "    }",
      "    let rows = a.len();",
      "    let cols = b[0].len();",
      "    let common_dim = a[0].len();",
      "",
      "    let mut result = vec![vec![T::default(); cols]; rows];",
      "",
      "    for i in 0..rows {",
      "        for j in 0..cols {",
      "            result[i][j] = (0..common_dim).map(|k| a[i][k] * b[k][j]).sum();",
      "        }",
      "    }",
      "    Some(result)",
      "}"
    ],
    "description": "A function to multiply two 2D matrices in Rust using generics."
  },
  "_quickfind": {
    "prefix": "_quickfind",
    "body": [
      "pub struct QuickFind {",
      "    leader: Vec<usize>,",
      "    members: Vec<Vec<usize>>,",
      "    diff: Vec<i64>,",
      "}",
      "impl QuickFind {",
      "    pub fn new(n: usize) -> Self {",
      "        Self {",
      "            leader: (0..n).collect(),",
      "            members: (0..n).map(|i| vec![i]).collect(),",
      "            diff: vec![0; n],",
      "        }",
      "    }",
      "",
      "    pub fn union(&mut self, i: usize, j: usize, d: i64) -> Result<(), ()> {",
      "        let d = d + self.diff[j] - self.diff[i];",
      "        let i = self.leader[i];",
      "        let j = self.leader[j];",
      "        if i == j {",
      "            return (d == 0).then_some(()).ok_or(());",
      "        }",
      "        if self.members[i].len() < self.members[j].len() {",
      "            for &k in &self.members[i] {",
      "                self.leader[k] = self.leader[j];",
      "                self.diff[k] += d;",
      "            }",
      "            let members = std::mem::take(&mut self.members[i]);",
      "            self.members[j].extend(members);",
      "        } else {",
      "            for &k in &self.members[self.leader[j]] {",
      "                self.leader[k] = self.leader[i];",
      "                self.diff[k] -= d;",
      "            }",
      "            let members = std::mem::take(&mut self.members[j]);",
      "            self.members[i].extend(members);",
      "        }",
      "        Ok(())",
      "    }",
      "}"
    ],
    "description": "QuickFind data structure implementation in Rust."
  },
  "_potentialunionfind": {
    "prefix": "_potential_union_find",
    "body": [
      "pub struct PotentialUnionFind {",
      "    rank: Vec<usize>,",
      "    parent: Vec<usize>,",
      "    size: Vec<usize>,",
      "    diff_weight: Vec<isize>,",
      "}",
      "impl PotentialUnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        let rank = vec![0; n];",
      "        let parent = (0..n).collect::<Vec<_>>();",
      "        let size = vec![1; n];",
      "        let diff_weight = vec![0; n];",
      "        PotentialUnionFind { rank, parent, size, diff_weight }",
      "    }",
      "",
      "    pub fn leader(&mut self, n: usize) -> usize {",
      "        if self.parent[n] == n {",
      "            n",
      "        } else {",
      "            let r = self.leader(self.parent[n]);",
      "            self.diff_weight[n] += self.diff_weight[self.parent[n]];",
      "            self.parent[n] = r;",
      "            r",
      "        }",
      "    }",
      "",
      "    pub fn weight(&mut self, n: usize) -> isize {",
      "        self.leader(n);",
      "        self.diff_weight[n]",
      "    }",
      "",
      "    pub fn merge(&mut self, a: usize, b: usize, w: isize) {",
      "        let w = w + self.weight(a) - self.weight(b);",
      "        let a = self.leader(a);",
      "        let b = self.leader(b);",
      "        if a == b {",
      "            return;",
      "        }",
      "        if self.rank[a] < self.rank[b] {",
      "            self.parent[a] = b;",
      "            self.size[b] += self.size[a];",
      "            self.diff_weight[a] = -w;",
      "        } else {",
      "            self.parent[b] = a;",
      "            self.size[a] += self.size[b];",
      "            if self.rank[a] == self.rank[b] {",
      "                self.rank[a] += 1;",
      "            }",
      "            self.diff_weight[b] = w;",
      "        }",
      "    }",
      "",
      "    pub fn diff(&mut self, a: usize, b: usize) -> isize {",
      "        self.weight(b) - self.weight(a)",
      "    }",
      "",
      "    pub fn same(&mut self, a: usize, b: usize) -> bool {",
      "        self.leader(a) == self.leader(b)",
      "    }",
      "",
      "    pub fn size(&mut self, n: usize) -> usize {",
      "        let leader = self.leader(n);",
      "        return self.size[leader];",
      "    }",
      "}"
    ],
    "description": "Potential Union-Find data structure implementation in Rust."
  },
  "_scanner": {
    "prefix": "_scanner",
    "body": [
      "use std::{io::{stdin, Read}, str::FromStr};",
      "",
      "pub struct Scanner<I: Iterator<Item = char>> {",
      "    iter: std::iter::Peekable<I>,",
      "}",
      "",
      "macro_rules! exit {",
      "    () => {{",
      "        exit!(0)",
      "    }};",
      "    (\\$code:expr) => {{",
      "        std::process::exit(\\$code);",
      "    }}",
      "}",
      "",
      "impl<I: Iterator<Item = char>> Scanner<I> {",
      "    pub fn new(iter: I) -> Scanner<I> {",
      "        Scanner {",
      "            iter: iter.peekable(),",
      "        }",
      "    }",
      "",
      "    pub fn safe_get_token(&mut self) -> Option<String> {",
      "        let token = self.iter",
      "            .by_ref()",
      "            .skip_while(|c| c.is_whitespace())",
      "            .take_while(|c| !c.is_whitespace())",
      "            .collect::<String>();",
      "        if token.is_empty() {",
      "            None",
      "        } else {",
      "            Some(token)",
      "        }",
      "    }",
      "",
      "    pub fn token(&mut self) -> String {",
      "        self.safe_get_token().unwrap_or_else(|| exit!())",
      "    }",
      "",
      "    pub fn get<T: FromStr>(&mut self) -> T {",
      "        self.token().parse::<T>().unwrap_or_else(|_| exit!())",
      "    }",
      "",
      "    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {",
      "        (0..len).map(|_| self.get()).collect()",
      "    }",
      "",
      "    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {",
      "        (0..row).map(|_| self.vec(col)).collect()",
      "    }",
      "",
      "    pub fn char(&mut self) -> char {",
      "        self.iter.next().unwrap_or_else(|| exit!())",
      "    }",
      "",
      "    pub fn chars(&mut self) -> Vec<char> {",
      "        self.get::<String>().chars().collect()",
      "    }",
      "",
      "    pub fn line(&mut self) -> String {",
      "        if self.peek().is_some() {",
      "            self.iter",
      "                .by_ref()",
      "                .take_while(|&c| !(c == '\\n' || c == '\\r'))",
      "                .collect::<String>()",
      "        } else {",
      "            exit!();",
      "        }",
      "    }",
      "",
      "    pub fn peek(&mut self) -> Option<&char> {",
      "        self.iter.peek()",
      "    }",
      "}",
      "",
      "fn main() {",
      "    let cin = stdin().lock();",
      "    let mut sc = Scanner::new(cin.bytes().map(|e| e.unwrap() as char));",
      "    loop {",
      "        let w: usize = sc.get();",
      "        let h: usize = sc.get();",
      "    }",
      "}"
    ],
    "description": "Scanner struct for reading from stdin, useful for competitive programming."
  },
  "_rerooting": {
    "prefix": "_rerooting",
    "body": [
      "fn rerooting<",
      "    T: Clone,",
      "    E: IntoIterator<Item = (usize, usize)>,",
      "    F: FnMut(T, T) -> T,",
      "    G: FnMut(T, usize) -> T,",
      ">(",
      "    node_count: usize,",
      "    edges: E,",
      "    identity: T,",
      "    mut merge_operate: F,",
      "    mut operate_node: G,",
      ") -> Vec<T> {",
      "    const NO_PARENT: usize = std::usize::MAX;",
      "    //to[i] := 隣接している頂点の配列",
      "    let mut to = vec![vec![]; node_count];",
      "    //index_to[i][j] := adjacents[i][j](iのj番目の隣接頂点)にとって、iが何番目の隣接頂点か",
      "    let mut index_to = vec![vec![]; node_count];",
      "",
      "    for (u, v) in edges {",
      "        index_to[u].push(to[v].len());",
      "        index_to[v].push(to[u].len());",
      "        to[u].push(v);",
      "        to[v].push(u);",
      "    }",
      "",
      "    if node_count == 0 {",
      "        return vec![];",
      "    }",
      "",
      "    if node_count == 1 {",
      "        return vec![operate_node(identity, 0)];",
      "    }",
      "    //parents[i] := 一時的な根付き木として考えた時の、ノードiについての親",
      "    let mut parents = vec![0; node_count];",
      "    // order: BFS などで深さ順に並べた配列 (親が先・子が後)",
      "    // この配列を深さの大きい順(後ろから)に処理することで",
      "    // 「子が先、親が後」の計算順序を満たす",
      "    // 厳密には行きがけじゅんじゃないよ",
      "    let mut order = vec![0; node_count];",
      "",
      "    // initialize ordered tree",
      "    // BFSして頂点0(1頂点から)のみの答えをとりあえず出す",
      "    // 「子が先、親が後」の計算順序を満たす",
      "    // 厳密には行きがけじゅんじゃないよ",
      "    {",
      "        let mut count = 0;",
      "        let mut stack = vec![0];",
      "        parents[0] = NO_PARENT;",
      "",
      "        while let Some(v) = stack.pop() {",
      "            order[count] = v;",
      "            count += 1;",
      "",
      "            for &v2 in to[v].iter() {",
      "                if v2 == parents[v] {",
      "                    continue;",
      "                }",
      "                stack.push(v2);",
      "                parents[v2] = v;",
      "            }",
      "        }",
      "    }",
      "",
      "    // dp[i][j] := 「親 = i、子 = to[i][j]」と見なしたときの部分木の DP 値",
      "    let mut dp = (0..node_count)",
      "        .map(|i| vec![identity.clone(); to[i].len()])",
      "        .collect::<Vec<_>>();",
      "    // from leaf",
      "    for i in (1..node_count).rev() {",
      "        // 今みている頂点",
      "        // order[count] = v;としているのでこれで子から親へが約束される",
      "        let node = order[i];",
      "        // その親",
      "        let parent = parents[node];",
      "",
      "        // 子方向から集めた値を accumulate する",
      "        let mut accum = identity.clone();",
      "        let mut parent_index = NO_PARENT;",
      "",
      "        for j in 0..to[node].len() {",
      "            if to[node][j] == parent {",
      "                parent_index = j;",
      "                continue;",
      "            }",
      "",
      "            // 子方向から集めた値を accumulate する",
      "            accum = merge_operate(accum, dp[node][j].to_owned());",
      "        }",
      "",
      "        dp[parent][index_to[node][parent_index]] = operate_node(accum, node);",
      "    }",
      "",
      "    let mut res = vec![identity.clone(); node_count];",
      "    let mut accums_from_tail = vec![];",
      "",
      "    // to leaf",
      "    for i in 0..node_count {",
      "        let node = order[i];",
      "        let deg = to[node].len();",
      "        let mut accum = identity.clone();",
      "",
      "        accums_from_tail.clear();",
      "        accums_from_tail.extend(std::iter::repeat(identity.clone()).take(deg));",
      "",
      "        for j in (1..deg).rev() {",
      "            accums_from_tail[j - 1] = merge_operate(accums_from_tail[j].clone(), dp[node][j].clone());",
      "        }",
      "",
      "        for j in 0..deg {",
      "            dp[to[node][j]][index_to[node][j]] =",
      "                operate_node(merge_operate(accum.clone(), accums_from_tail[j].clone()), node);",
      "            accum = merge_operate(accum, dp[node][j].clone());",
      "        }",
      "",
      "        res[node] = operate_node(accum, node);",
      "    }",
      "",
      "    res",
      "}"
    ],
    "description": "Rerooting DP function with detailed comments in Rust"
  }
}
